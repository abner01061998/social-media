<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>turbo-118a59d5569d8a8b343ee3cd7f2c39b6b5fa5f236368b332e2db7bdad59d1ca9.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../Gemfile.html">Gemfile</a>
    <li><a href="../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../README_md.html">README</a>
    <li><a href="../../Rakefile.html">Rakefile</a>
    <li><a href="../../app/assets/config/manifest_js.html">manifest.js</a>
    <li><a href="../../app/assets/stylesheets/application_scss.html">application.scss</a>
    <li><a href="../../app/assets/stylesheets/custom_css.html">custom.css</a>
    <li><a href="../../app/javascript/application_js.html">application.js</a>
    <li><a href="../../app/javascript/controllers/application_js.html">application.js</a>
    <li><a href="../../app/javascript/controllers/hello_controller_js.html">hello_controller.js</a>
    <li><a href="../../app/javascript/controllers/index_js.html">index.js</a>
    <li><a href="../../bin/bundle_cmd.html">bundle.cmd</a>
    <li><a href="../../config_ru.html">config.ru</a>
    <li><a href="../../config/credentials_yml_enc.html">credentials.yml.enc</a>
    <li><a href="../../config/master_key.html">master.key</a>
    <li><a href="../../db/production_sqlite3.html">production.sqlite3</a>
    <li><a href="../../log/development_log.html">development.log</a>
    <li><a href="../../log/production_log.html">production.log</a>
    <li><a href="../../public/404_html.html">404.html</a>
    <li><a href="../../public/422_html.html">422.html</a>
    <li><a href="../../public/500_html.html">500.html</a>
    <li><a href="../../public/apple-touch-icon-precomposed_png.html">apple-touch-icon-precomposed.png</a>
    <li><a href="../../public/apple-touch-icon_png.html">apple-touch-icon.png</a>
    <li><a href="../../public/assets/actioncable-5433453f9b6619a9de91aaab2d7fc7ff183e5260c0107cbc9a1aa0c838d9a74e_js.html">actioncable-5433453f9b6619a9de91aaab2d7fc7ff183e5260c0107cbc9a1aa0c838d9a74e.js</a>
    <li><a href="../../public/assets/actioncable_esm-e01089c3ec4fe7817fa9abcad06cab6bdc387f95f0ca6aab4bf7ba7537f70690_js.html">actioncable.esm-e01089c3ec4fe7817fa9abcad06cab6bdc387f95f0ca6aab4bf7ba7537f70690.js</a>
    <li><a href="../../public/assets/actiontext-28c61f5197c204db043317a8f8826a87ab31495b741f854d307ca36122deefce_js.html">actiontext-28c61f5197c204db043317a8f8826a87ab31495b741f854d307ca36122deefce.js</a>
    <li><a href="../../public/assets/activestorage-3ab61e47dd4ee2d79db525ade1dca2ede0ea2b7371fe587e408ee37b7ade265d_js.html">activestorage-3ab61e47dd4ee2d79db525ade1dca2ede0ea2b7371fe587e408ee37b7ade265d.js</a>
    <li><a href="../../public/assets/activestorage_esm-01f58a45d77495cdfbdfcc872902a430426c4391634ec9c3da5f69fbf8418492_js.html">activestorage.esm-01f58a45d77495cdfbdfcc872902a430426c4391634ec9c3da5f69fbf8418492.js</a>
    <li><a href="../../public/assets/application-32d4b75e744a8a8e755359e6017482014dee13b0c2f0861d571e55531d39a79d_css.html">application-32d4b75e744a8a8e755359e6017482014dee13b0c2f0861d571e55531d39a79d.css</a>
    <li><a href="../../public/assets/application-3e73deab22b3cbf32eae8a405cc3f28cfe3ab81a37fecca6ddbbe46c75af5b0e_css.html">application-3e73deab22b3cbf32eae8a405cc3f28cfe3ab81a37fecca6ddbbe46c75af5b0e.css</a>
    <li><a href="../../public/assets/application-4668a63fc7682ef88af586a54008d0c129dc516b342577afb0de28e081796840_css.html">application-4668a63fc7682ef88af586a54008d0c129dc516b342577afb0de28e081796840.css</a>
    <li><a href="../../public/assets/application-7ac6076e7d9cab030797f1bfe2cf764861a60dc215f623dde8cb933ae0bf10dc_js.html">application-7ac6076e7d9cab030797f1bfe2cf764861a60dc215f623dde8cb933ae0bf10dc.js</a>
    <li><a href="../../public/assets/application-a44e181b486d978d63932a4db09338ae502d90e10c0bdd395aa839123aeea2ec_css.html">application-a44e181b486d978d63932a4db09338ae502d90e10c0bdd395aa839123aeea2ec.css</a>
    <li><a href="../../public/assets/application-ac2e01aa9a494aeeba9e1c95a30a26e3dd5b5ac439d25b67aa38832295e26c3d_css.html">application-ac2e01aa9a494aeeba9e1c95a30a26e3dd5b5ac439d25b67aa38832295e26c3d.css</a>
    <li><a href="../../public/assets/application-dc2d2d6cd177033c4b2946f0fdc563dc111e103bced6042c2b7649f314306f58_css.html">application-dc2d2d6cd177033c4b2946f0fdc563dc111e103bced6042c2b7649f314306f58.css</a>
    <li><a href="../../public/assets/bootstrap_min-20a034247d4d545a7a2d49d62ee00c40f53f825562ed9d6c9af1ad42383e67f6_js.html">bootstrap.min-20a034247d4d545a7a2d49d62ee00c40f53f825562ed9d6c9af1ad42383e67f6.js</a>
    <li><a href="../../public/assets/controllers/application-368d98631bccbf2349e0d4f8269afb3fe9625118341966de054759d96ea86c7e_js.html">application-368d98631bccbf2349e0d4f8269afb3fe9625118341966de054759d96ea86c7e.js</a>
    <li><a href="../../public/assets/controllers/hello_controller-549135e8e7c683a538c3d6d517339ba470fcfb79d62f738a0a089ba41851a554_js.html">hello_controller-549135e8e7c683a538c3d6d517339ba470fcfb79d62f738a0a089ba41851a554.js</a>
    <li><a href="../../public/assets/controllers/index-2db729dddcc5b979110e98de4b6720f83f91a123172e87281d5a58410fc43806_js.html">index-2db729dddcc5b979110e98de4b6720f83f91a123172e87281d5a58410fc43806.js</a>
    <li><a href="../../public/assets/custom-77945ec94022f825cfe7d6166e97092d87ca4f55627c8062b56cfb9f1a35f205_css.html">custom-77945ec94022f825cfe7d6166e97092d87ca4f55627c8062b56cfb9f1a35f205.css</a>
    <li><a href="../../public/assets/custom-7eba9728e51d5c26d8d1cf50340b4b3ad9251d8a5f0142ef57211377bd50fcfc_css.html">custom-7eba9728e51d5c26d8d1cf50340b4b3ad9251d8a5f0142ef57211377bd50fcfc.css</a>
    <li><a href="../../public/assets/custom-de99a0f588d04e64f8aa62da913f7225b090eb13fbfe74a7315f1715cdefec1d_css.html">custom-de99a0f588d04e64f8aa62da913f7225b090eb13fbfe74a7315f1715cdefec1d.css</a>
    <li><a href="../../public/assets/custom-e30bda1bcb7eaa86b4f7970e250dadbfd4aa17f32943e7e25ef353bd822fd884_css.html">custom-e30bda1bcb7eaa86b4f7970e250dadbfd4aa17f32943e7e25ef353bd822fd884.css</a>
    <li><a href="../../public/assets/es-module-shims-16719834c9bbcdd75f1f99da713bd0c89de488be94d4c5df594511f39cffe7c1_js.html">es-module-shims-16719834c9bbcdd75f1f99da713bd0c89de488be94d4c5df594511f39cffe7c1.js</a>
    <li><a href="../../public/assets/es-module-shims_js-32db422c5db541b7129a2ce936aed905edc2cd481748f8d67ffe84e28313158a_map.html">es-module-shims.js-32db422c5db541b7129a2ce936aed905edc2cd481748f8d67ffe84e28313158a.map</a>
    <li><a href="../../public/assets/es-module-shims_min-d89e73202ec09dede55fb74115af9c5f9f2bb965433de1c2446e1faa6dac2470_js.html">es-module-shims.min-d89e73202ec09dede55fb74115af9c5f9f2bb965433de1c2446e1faa6dac2470.js</a>
    <li><a href="../../public/assets/manifest-b84bfa46a33d7f0dc4d2e7b8889486c9a957a5e40713d58f54be71b66954a1ff_js.html">manifest-b84bfa46a33d7f0dc4d2e7b8889486c9a957a5e40713d58f54be71b66954a1ff.js</a>
    <li><a href="../../public/assets/popper-15792033e209365e7b75c100dae2b69cba31b26b18b289383d22eb67639aad75_js.html">popper-15792033e209365e7b75c100dae2b69cba31b26b18b289383d22eb67639aad75.js</a>
    <li><a href="../../public/assets/stimulus-2e76632599c700da6e187ce7b15eea7c0eace0e09f25d19e55e3b1f7c515397c_js.html">stimulus-2e76632599c700da6e187ce7b15eea7c0eace0e09f25d19e55e3b1f7c515397c.js</a>
    <li><a href="../../public/assets/stimulus-autoloader-c584942b568ba74879da31c7c3d51366737bacaf6fbae659383c0a5653685693_js.html">stimulus-autoloader-c584942b568ba74879da31c7c3d51366737bacaf6fbae659383c0a5653685693.js</a>
    <li><a href="../../public/assets/stimulus-importmap-autoloader-db2076c783bf2dbee1226e2add52fef290b5d31b5bcd1edd999ac8a6dd31c44a_js.html">stimulus-importmap-autoloader-db2076c783bf2dbee1226e2add52fef290b5d31b5bcd1edd999ac8a6dd31c44a.js</a>
    <li><a href="../../public/assets/stimulus-loading-1fc59770fb1654500044afd3f5f6d7d00800e5be36746d55b94a2963a7a228aa_js.html">stimulus-loading-1fc59770fb1654500044afd3f5f6d7d00800e5be36746d55b94a2963a7a228aa.js</a>
    <li><a href="../../public/assets/stimulus_min-b8a9738499c7a8362910cd545375417370d72a9776fb4e766df7671484e2beb7_js.html">stimulus.min-b8a9738499c7a8362910cd545375417370d72a9776fb4e766df7671484e2beb7.js</a>
    <li><a href="../../public/assets/stimulus_min_js-8d1a076cbda7e5ed0992e208db54c62a8de8b1f9694828e1a601fbccd9291649_map.html">stimulus.min.js-8d1a076cbda7e5ed0992e208db54c62a8de8b1f9694828e1a601fbccd9291649.map</a>
    <li><a href="../../public/assets/trix-1563ff9c10f74e143b3ded40a8458497eaf2f87a648a5cbbfebdb7dec3447a5e_js.html">trix-1563ff9c10f74e143b3ded40a8458497eaf2f87a648a5cbbfebdb7dec3447a5e.js</a>
    <li><a href="../../public/assets/trix-fe178d6f8c056d8e63aecb6557bc65676897f43e4aee3e68584437841a99fc23_css.html">trix-fe178d6f8c056d8e63aecb6557bc65676897f43e4aee3e68584437841a99fc23.css</a>
    <li><a href="../../public/assets/turbo-118a59d5569d8a8b343ee3cd7f2c39b6b5fa5f236368b332e2db7bdad59d1ca9_js.html">turbo-118a59d5569d8a8b343ee3cd7f2c39b6b5fa5f236368b332e2db7bdad59d1ca9.js</a>
    <li><a href="../../public/assets/turbo_min-3b666ce240bde65e66d795553a062443a3b139e38646fe31740d354a41653fcc_js.html">turbo.min-3b666ce240bde65e66d795553a062443a3b139e38646fe31740d354a41653fcc.js</a>
    <li><a href="../../public/assets/turbo_min_js-c3141c67d707e81f67affd6a77f1657e298d5cb8aac6628e892669905b33786e_map.html">turbo.min.js-c3141c67d707e81f67affd6a77f1657e298d5cb8aac6628e892669905b33786e.map</a>
    <li><a href="../../public/favicon_ico.html">favicon.ico</a>
    <li><a href="../../public/robots_txt.html">robots</a>
    <li><a href="../../tmp/development_secret_txt.html">development_secret</a>
    <li><a href="../../tmp/pids/server_pid.html">server.pid</a>
    <li><a href="../../tmp/restart_txt.html">restart</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page public/assets/turbo-118a59d5569d8a8b343ee3cd7f2c39b6b5fa5f236368b332e2db7bdad59d1ca9.js">

<p>(function() {</p>

<pre>if (window.Reflect === undefined || window.customElements === undefined || window.customElements.polyfillWrapFlushCallback) {
  return;
}
const BuiltInHTMLElement = HTMLElement;
const wrapperForTheName = {
  HTMLElement: function HTMLElement() {
    return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
  }
};
window.HTMLElement = wrapperForTheName[&quot;HTMLElement&quot;];
HTMLElement.prototype = BuiltInHTMLElement.prototype;
HTMLElement.prototype.constructor = HTMLElement;
Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);</pre>

<p>})();</p>

<p>(function(prototype) {</p>

<pre>if (typeof prototype.requestSubmit == &quot;function&quot;) return;
prototype.requestSubmit = function(submitter) {
  if (submitter) {
    validateSubmitter(submitter, this);
    submitter.click();
  } else {
    submitter = document.createElement(&quot;input&quot;);
    submitter.type = &quot;submit&quot;;
    submitter.hidden = true;
    this.appendChild(submitter);
    submitter.click();
    this.removeChild(submitter);
  }
};
function validateSubmitter(submitter, form) {
  submitter instanceof HTMLElement || raise(TypeError, &quot;parameter 1 is not of type &#39;HTMLElement&#39;&quot;);
  submitter.type == &quot;submit&quot; || raise(TypeError, &quot;The specified element is not a submit button&quot;);
  submitter.form == form || raise(DOMException, &quot;The specified element is not owned by this form element&quot;, &quot;NotFoundError&quot;);
}
function raise(errorConstructor, message, name) {
  throw new errorConstructor(&quot;Failed to execute &#39;requestSubmit&#39; on &#39;HTMLFormElement&#39;: &quot; + message + &quot;.&quot;, name);
}</pre>

<p>})(HTMLFormElement.prototype);</p>

<p>const submittersByForm = new WeakMap;</p>

<p>function findSubmitterFromClickTarget(target) {</p>

<pre>const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
const candidate = element ? element.closest(&quot;input, button&quot;) : null;
return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == &quot;submit&quot; ? candidate : null;</pre>

<p>}</p>

<p>function clickCaptured(event) {</p>

<pre>const submitter = findSubmitterFromClickTarget(event.target);
if (submitter &amp;&amp; submitter.form) {
  submittersByForm.set(submitter.form, submitter);
}</pre>

<p>}</p>

<p>(function() {</p>

<pre>if (&quot;submitter&quot; in Event.prototype) return;
let prototype;
if (&quot;SubmitEvent&quot; in window &amp;&amp; /Apple Computer/.test(navigator.vendor)) {
  prototype = window.SubmitEvent.prototype;
} else if (&quot;SubmitEvent&quot; in window) {
  return;
} else {
  prototype = window.Event.prototype;
}
addEventListener(&quot;click&quot;, clickCaptured, true);
Object.defineProperty(prototype, &quot;submitter&quot;, {
  get() {
    if (this.type == &quot;submit&quot; &amp;&amp; this.target instanceof HTMLFormElement) {
      return submittersByForm.get(this.target);
    }
  }
});</pre>

<p>})();</p>

<p>var FrameLoadingStyle;</p>

<p>(function(FrameLoadingStyle) {</p>

<pre class="ruby"><span class="ruby-constant">FrameLoadingStyle</span>[<span class="ruby-string">&quot;eager&quot;</span>] = <span class="ruby-string">&quot;eager&quot;</span>;
<span class="ruby-constant">FrameLoadingStyle</span>[<span class="ruby-string">&quot;lazy&quot;</span>] = <span class="ruby-string">&quot;lazy&quot;</span>;
</pre>

<p>})(FrameLoadingStyle || (FrameLoadingStyle = {}));</p>

<p>class FrameElement extends HTMLElement {</p>

<pre>constructor() {
  super();
  this.loaded = Promise.resolve();
  this.delegate = new FrameElement.delegateConstructor(this);
}
static get observedAttributes() {
  return [ &quot;disabled&quot;, &quot;complete&quot;, &quot;loading&quot;, &quot;src&quot; ];
}
connectedCallback() {
  this.delegate.connect();
}
disconnectedCallback() {
  this.delegate.disconnect();
}
reload() {
  const {src: src} = this;
  this.removeAttribute(&quot;complete&quot;);
  this.src = null;
  this.src = src;
  return this.loaded;
}
attributeChangedCallback(name) {
  if (name == &quot;loading&quot;) {
    this.delegate.loadingStyleChanged();
  } else if (name == &quot;complete&quot;) {
    this.delegate.completeChanged();
  } else if (name == &quot;src&quot;) {
    this.delegate.sourceURLChanged();
  } else {
    this.delegate.disabledChanged();
  }
}
get src() {
  return this.getAttribute(&quot;src&quot;);
}
set src(value) {
  if (value) {
    this.setAttribute(&quot;src&quot;, value);
  } else {
    this.removeAttribute(&quot;src&quot;);
  }
}
get loading() {
  return frameLoadingStyleFromString(this.getAttribute(&quot;loading&quot;) || &quot;&quot;);
}
set loading(value) {
  if (value) {
    this.setAttribute(&quot;loading&quot;, value);
  } else {
    this.removeAttribute(&quot;loading&quot;);
  }
}
get disabled() {
  return this.hasAttribute(&quot;disabled&quot;);
}
set disabled(value) {
  if (value) {
    this.setAttribute(&quot;disabled&quot;, &quot;&quot;);
  } else {
    this.removeAttribute(&quot;disabled&quot;);
  }
}
get autoscroll() {
  return this.hasAttribute(&quot;autoscroll&quot;);
}
set autoscroll(value) {
  if (value) {
    this.setAttribute(&quot;autoscroll&quot;, &quot;&quot;);
  } else {
    this.removeAttribute(&quot;autoscroll&quot;);
  }
}
get complete() {
  return !this.delegate.isLoading;
}
get isActive() {
  return this.ownerDocument === document &amp;&amp; !this.isPreview;
}
get isPreview() {
  var _a, _b;
  return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute(&quot;data-turbo-preview&quot;);
}</pre>

<p>}</p>

<p>function frameLoadingStyleFromString(style) {</p>

<pre>switch (style.toLowerCase()) {
 case &quot;lazy&quot;:
  return FrameLoadingStyle.lazy;

 default:
  return FrameLoadingStyle.eager;
}</pre>

<p>}</p>

<p>function expandURL(locatable) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">URL</span>(<span class="ruby-identifier">locatable</span>.<span class="ruby-identifier">toString</span>(), <span class="ruby-identifier">document</span>.<span class="ruby-identifier">baseURI</span>);
</pre>

<p>}</p>

<p>function getAnchor(url) {</p>

<pre>let anchorMatch;
if (url.hash) {
  return url.hash.slice(1);
} else if (anchorMatch = url.href.match(/#(.*)$/)) {
  return anchorMatch[1];
}</pre>

<p>}</p>

<p>function getAction(form, submitter) {</p>

<pre>const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(&quot;formaction&quot;)) || form.getAttribute(&quot;action&quot;) || form.action;
return expandURL(action);</pre>

<p>}</p>

<p>function getExtension(url) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> (<span class="ruby-identifier">getLastPathComponent</span>(<span class="ruby-identifier">url</span>).<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/\.[^.]*$/</span>) <span class="ruby-operator">||</span> [])[<span class="ruby-value">0</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>;
</pre>

<p>}</p>

<p>function isHTML(url) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">getExtension</span>(<span class="ruby-identifier">url</span>).<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/^(?:|\.(?:htm|html|xhtml|php))$/</span>);
</pre>

<p>}</p>

<p>function isPrefixedBy(baseURL, url) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">prefix</span> = <span class="ruby-identifier">getPrefix</span>(<span class="ruby-identifier">url</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">baseURL</span>.<span class="ruby-identifier">href</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">expandURL</span>(<span class="ruby-identifier">prefix</span>).<span class="ruby-identifier">href</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">baseURL</span>.<span class="ruby-identifier">href</span>.<span class="ruby-identifier">startsWith</span>(<span class="ruby-identifier">prefix</span>);
</pre>

<p>}</p>

<p>function locationIsVisitable(location, rootLocation) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">isPrefixedBy</span>(<span class="ruby-identifier">location</span>, <span class="ruby-identifier">rootLocation</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">isHTML</span>(<span class="ruby-identifier">location</span>);
</pre>

<p>}</p>

<p>function getRequestURL(url) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">anchor</span> = <span class="ruby-identifier">getAnchor</span>(<span class="ruby-identifier">url</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">anchor</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">href</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>, <span class="ruby-operator">-</span>(<span class="ruby-identifier">anchor</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)) <span class="ruby-operator">:</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">href</span>;
</pre>

<p>}</p>

<p>function toCacheKey(url) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">getRequestURL</span>(<span class="ruby-identifier">url</span>);
</pre>

<p>}</p>

<p>function urlsAreEqual(left, right) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">expandURL</span>(<span class="ruby-identifier">left</span>).<span class="ruby-identifier">href</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">expandURL</span>(<span class="ruby-identifier">right</span>).<span class="ruby-identifier">href</span>;
</pre>

<p>}</p>

<p>function getPathComponents(url) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">pathname</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&quot;/&quot;</span>).<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span>);
</pre>

<p>}</p>

<p>function getLastPathComponent(url) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">getPathComponents</span>(<span class="ruby-identifier">url</span>).<span class="ruby-identifier">slice</span>(<span class="ruby-value">-1</span>)[<span class="ruby-value">0</span>];
</pre>

<p>}</p>

<p>function getPrefix(url) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">addTrailingSlash</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">origin</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">pathname</span>);
</pre>

<p>}</p>

<p>function addTrailingSlash(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">endsWith</span>(<span class="ruby-string">&quot;/&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;/&quot;</span>;
</pre>

<p>}</p>

<p>class FetchResponse {</p>

<pre>constructor(response) {
  this.response = response;
}
get succeeded() {
  return this.response.ok;
}
get failed() {
  return !this.succeeded;
}
get clientError() {
  return this.statusCode &gt;= 400 &amp;&amp; this.statusCode &lt;= 499;
}
get serverError() {
  return this.statusCode &gt;= 500 &amp;&amp; this.statusCode &lt;= 599;
}
get redirected() {
  return this.response.redirected;
}
get location() {
  return expandURL(this.response.url);
}
get isHTML() {
  return this.contentType &amp;&amp; this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
}
get statusCode() {
  return this.response.status;
}
get contentType() {
  return this.header(&quot;Content-Type&quot;);
}
get responseText() {
  return this.response.clone().text();
}
get responseHTML() {
  if (this.isHTML) {
    return this.response.clone().text();
  } else {
    return Promise.resolve(undefined);
  }
}
header(name) {
  return this.response.headers.get(name);
}</pre>

<p>}</p>

<p>function isAction(action) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">action</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;advance&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">action</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;replace&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">action</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;restore&quot;</span>;
</pre>

<p>}</p>

<p>function activateScriptElement(element) {</p>

<pre>if (element.getAttribute(&quot;data-turbo-eval&quot;) == &quot;false&quot;) {
  return element;
} else {
  const createdScriptElement = document.createElement(&quot;script&quot;);
  const cspNonce = getMetaContent(&quot;csp-nonce&quot;);
  if (cspNonce) {
    createdScriptElement.nonce = cspNonce;
  }
  createdScriptElement.textContent = element.textContent;
  createdScriptElement.async = false;
  copyElementAttributes(createdScriptElement, element);
  return createdScriptElement;
}</pre>

<p>}</p>

<p>function copyElementAttributes(destinationElement, sourceElement) {</p>

<pre>for (const {name: name, value: value} of sourceElement.attributes) {
  destinationElement.setAttribute(name, value);
}</pre>

<p>}</p>

<p>function createDocumentFragment(html) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">template</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">createElement</span>(<span class="ruby-string">&quot;template&quot;</span>);
<span class="ruby-identifier">template</span>.<span class="ruby-identifier">innerHTML</span> = <span class="ruby-identifier">html</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">template</span>.<span class="ruby-identifier">content</span>;
</pre>

<p>}</p>

<p>function dispatch(eventName, {target: target, cancelable: cancelable, detail: detail} = {}) {</p>

<pre>const event = new CustomEvent(eventName, {
  cancelable: cancelable,
  bubbles: true,
  detail: detail
});
if (target &amp;&amp; target.isConnected) {
  target.dispatchEvent(event);
} else {
  document.documentElement.dispatchEvent(event);
}
return event;</pre>

<p>}</p>

<p>function nextAnimationFrame() {</p>

<pre>return new Promise((resolve =&gt; requestAnimationFrame((() =&gt; resolve()))));</pre>

<p>}</p>

<p>function nextEventLoopTick() {</p>

<pre>return new Promise((resolve =&gt; setTimeout((() =&gt; resolve()), 0)));</pre>

<p>}</p>

<p>function nextMicrotask() {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">resolve</span>();
</pre>

<p>}</p>

<p>function parseHTMLDocument(html = “”) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> (<span class="ruby-identifier">new</span> <span class="ruby-constant">DOMParser</span>).<span class="ruby-identifier">parseFromString</span>(<span class="ruby-identifier">html</span>, <span class="ruby-string">&quot;text/html&quot;</span>);
</pre>

<p>}</p>

<p>function unindent(strings, …values) {</p>

<pre>const lines = interpolate(strings, values).replace(/^\n/, &quot;&quot;).split(&quot;\n&quot;);
const match = lines[0].match(/^\s+/);
const indent = match ? match[0].length : 0;
return lines.map((line =&gt; line.slice(indent))).join(&quot;\n&quot;);</pre>

<p>}</p>

<p>function interpolate(strings, values) {</p>

<pre>return strings.reduce(((result, string, i) =&gt; {
  const value = values[i] == undefined ? &quot;&quot; : values[i];
  return result + string + value;
}), &quot;&quot;);</pre>

<p>}</p>

<p>function uuid() {</p>

<pre>return Array.from({
  length: 36
}).map(((_, i) =&gt; {
  if (i == 8 || i == 13 || i == 18 || i == 23) {
    return &quot;-&quot;;
  } else if (i == 14) {
    return &quot;4&quot;;
  } else if (i == 19) {
    return (Math.floor(Math.random() * 4) + 8).toString(16);
  } else {
    return Math.floor(Math.random() * 15).toString(16);
  }
})).join(&quot;&quot;);</pre>

<p>}</p>

<p>function getAttribute(attributeName, …elements) {</p>

<pre>for (const value of elements.map((element =&gt; element === null || element === void 0 ? void 0 : element.getAttribute(attributeName)))) {
  if (typeof value == &quot;string&quot;) return value;
}
return null;</pre>

<p>}</p>

<p>function hasAttribute(attributeName, …elements) {</p>

<pre>return elements.some((element =&gt; element &amp;&amp; element.hasAttribute(attributeName)));</pre>

<p>}</p>

<p>function markAsBusy(…elements) {</p>

<pre>for (const element of elements) {
  if (element.localName == &quot;turbo-frame&quot;) {
    element.setAttribute(&quot;busy&quot;, &quot;&quot;);
  }
  element.setAttribute(&quot;aria-busy&quot;, &quot;true&quot;);
}</pre>

<p>}</p>

<p>function clearBusyState(…elements) {</p>

<pre>for (const element of elements) {
  if (element.localName == &quot;turbo-frame&quot;) {
    element.removeAttribute(&quot;busy&quot;);
  }
  element.removeAttribute(&quot;aria-busy&quot;);
}</pre>

<p>}</p>

<p>function waitForLoad(element, timeoutInMilliseconds = 2e3) {</p>

<pre>return new Promise((resolve =&gt; {
  const onComplete = () =&gt; {
    element.removeEventListener(&quot;error&quot;, onComplete);
    element.removeEventListener(&quot;load&quot;, onComplete);
    resolve();
  };
  element.addEventListener(&quot;load&quot;, onComplete, {
    once: true
  });
  element.addEventListener(&quot;error&quot;, onComplete, {
    once: true
  });
  setTimeout(resolve, timeoutInMilliseconds);
}));</pre>

<p>}</p>

<p>function getHistoryMethodForAction(action) {</p>

<pre>switch (action) {
 case &quot;replace&quot;:
  return history.replaceState;

 case &quot;advance&quot;:
 case &quot;restore&quot;:
  return history.pushState;
}</pre>

<p>}</p>

<p>function getVisitAction(…elements) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">action</span> = <span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&quot;data-turbo-action&quot;</span>, <span class="ruby-operator">...</span><span class="ruby-identifier">elements</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">isAction</span>(<span class="ruby-identifier">action</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">action</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>;
</pre>

<p>}</p>

<p>function getMetaElement(name) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">querySelector</span>(<span class="ruby-string">`meta[name=&quot;${name}&quot;]`</span>);
</pre>

<p>}</p>

<p>function getMetaContent(name) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">element</span> = <span class="ruby-identifier">getMetaElement</span>(<span class="ruby-identifier">name</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">content</span>;
</pre>

<p>}</p>

<p>function setMetaContent(name, content) {</p>

<pre>let element = getMetaElement(name);
if (!element) {
  element = document.createElement(&quot;meta&quot;);
  element.setAttribute(&quot;name&quot;, name);
  document.head.appendChild(element);
}
element.setAttribute(&quot;content&quot;, content);
return element;</pre>

<p>}</p>

<p>var FetchMethod;</p>

<p>(function(FetchMethod) {</p>

<pre class="ruby"><span class="ruby-constant">FetchMethod</span>[<span class="ruby-constant">FetchMethod</span>[<span class="ruby-string">&quot;get&quot;</span>] = <span class="ruby-value">0</span>] = <span class="ruby-string">&quot;get&quot;</span>;
<span class="ruby-constant">FetchMethod</span>[<span class="ruby-constant">FetchMethod</span>[<span class="ruby-string">&quot;post&quot;</span>] = <span class="ruby-value">1</span>] = <span class="ruby-string">&quot;post&quot;</span>;
<span class="ruby-constant">FetchMethod</span>[<span class="ruby-constant">FetchMethod</span>[<span class="ruby-string">&quot;put&quot;</span>] = <span class="ruby-value">2</span>] = <span class="ruby-string">&quot;put&quot;</span>;
<span class="ruby-constant">FetchMethod</span>[<span class="ruby-constant">FetchMethod</span>[<span class="ruby-string">&quot;patch&quot;</span>] = <span class="ruby-value">3</span>] = <span class="ruby-string">&quot;patch&quot;</span>;
<span class="ruby-constant">FetchMethod</span>[<span class="ruby-constant">FetchMethod</span>[<span class="ruby-string">&quot;delete&quot;</span>] = <span class="ruby-value">4</span>] = <span class="ruby-string">&quot;delete&quot;</span>;
</pre>

<p>})(FetchMethod || (FetchMethod = {}));</p>

<p>function fetchMethodFromString(method) {</p>

<pre>switch (method.toLowerCase()) {
 case &quot;get&quot;:
  return FetchMethod.get;

 case &quot;post&quot;:
  return FetchMethod.post;

 case &quot;put&quot;:
  return FetchMethod.put;

 case &quot;patch&quot;:
  return FetchMethod.patch;

 case &quot;delete&quot;:
  return FetchMethod.delete;
}</pre>

<p>}</p>

<p>class FetchRequest {</p>

<pre>constructor(delegate, method, location, body = new URLSearchParams, target = null) {
  this.abortController = new AbortController;
  this.resolveRequestPromise = _value =&gt; {};
  this.delegate = delegate;
  this.method = method;
  this.headers = this.defaultHeaders;
  this.body = body;
  this.url = location;
  this.target = target;
}
get location() {
  return this.url;
}
get params() {
  return this.url.searchParams;
}
get entries() {
  return this.body ? Array.from(this.body.entries()) : [];
}
cancel() {
  this.abortController.abort();
}
async perform() {
  var _a, _b;
  const {fetchOptions: fetchOptions} = this;
  (_b = (_a = this.delegate).prepareHeadersForRequest) === null || _b === void 0 ? void 0 : _b.call(_a, this.headers, this);
  await this.allowRequestToBeIntercepted(fetchOptions);
  try {
    this.delegate.requestStarted(this);
    const response = await fetch(this.url.href, fetchOptions);
    return await this.receive(response);
  } catch (error) {
    if (error.name !== &quot;AbortError&quot;) {
      if (this.willDelegateErrorHandling(error)) {
        this.delegate.requestErrored(this, error);
      }
      throw error;
    }
  } finally {
    this.delegate.requestFinished(this);
  }
}
async receive(response) {
  const fetchResponse = new FetchResponse(response);
  const event = dispatch(&quot;turbo:before-fetch-response&quot;, {
    cancelable: true,
    detail: {
      fetchResponse: fetchResponse
    },
    target: this.target
  });
  if (event.defaultPrevented) {
    this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
  } else if (fetchResponse.succeeded) {
    this.delegate.requestSucceededWithResponse(this, fetchResponse);
  } else {
    this.delegate.requestFailedWithResponse(this, fetchResponse);
  }
  return fetchResponse;
}
get fetchOptions() {
  var _a;
  return {
    method: FetchMethod[this.method].toUpperCase(),
    credentials: &quot;same-origin&quot;,
    headers: this.headers,
    redirect: &quot;follow&quot;,
    body: this.isIdempotent ? null : this.body,
    signal: this.abortSignal,
    referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
  };
}
get defaultHeaders() {
  return {
    Accept: &quot;text/html, application/xhtml+xml&quot;
  };
}
get isIdempotent() {
  return this.method == FetchMethod.get;
}
get abortSignal() {
  return this.abortController.signal;
}
acceptResponseType(mimeType) {
  this.headers[&quot;Accept&quot;] = [ mimeType, this.headers[&quot;Accept&quot;] ].join(&quot;, &quot;);
}
async allowRequestToBeIntercepted(fetchOptions) {
  const requestInterception = new Promise((resolve =&gt; this.resolveRequestPromise = resolve));
  const event = dispatch(&quot;turbo:before-fetch-request&quot;, {
    cancelable: true,
    detail: {
      fetchOptions: fetchOptions,
      url: this.url,
      resume: this.resolveRequestPromise
    },
    target: this.target
  });
  if (event.defaultPrevented) await requestInterception;
}
willDelegateErrorHandling(error) {
  const event = dispatch(&quot;turbo:fetch-request-error&quot;, {
    target: this.target,
    cancelable: true,
    detail: {
      request: this,
      error: error
    }
  });
  return !event.defaultPrevented;
}</pre>

<p>}</p>

<p>class AppearanceObserver {</p>

<pre>constructor(delegate, element) {
  this.started = false;
  this.intersect = entries =&gt; {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  };
  this.delegate = delegate;
  this.element = element;
  this.intersectionObserver = new IntersectionObserver(this.intersect);
}
start() {
  if (!this.started) {
    this.started = true;
    this.intersectionObserver.observe(this.element);
  }
}
stop() {
  if (this.started) {
    this.started = false;
    this.intersectionObserver.unobserve(this.element);
  }
}</pre>

<p>}</p>

<p>class StreamMessage {</p>

<pre>constructor(fragment) {
  this.fragment = importStreamElements(fragment);
}
static wrap(message) {
  if (typeof message == &quot;string&quot;) {
    return new this(createDocumentFragment(message));
  } else {
    return message;
  }
}</pre>

<p>}</p>

<p>StreamMessage.contentType = “text/vnd.turbo-stream.html”;</p>

<p>function importStreamElements(fragment) {</p>

<pre>for (const element of fragment.querySelectorAll(&quot;turbo-stream&quot;)) {
  const streamElement = document.importNode(element, true);
  for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll(&quot;script&quot;)) {
    inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
  }
  element.replaceWith(streamElement);
}
return fragment;</pre>

<p>}</p>

<p>var FormSubmissionState;</p>

<p>(function(FormSubmissionState) {</p>

<pre class="ruby"><span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-string">&quot;initialized&quot;</span>] = <span class="ruby-value">0</span>] = <span class="ruby-string">&quot;initialized&quot;</span>;
<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-string">&quot;requesting&quot;</span>] = <span class="ruby-value">1</span>] = <span class="ruby-string">&quot;requesting&quot;</span>;
<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-string">&quot;waiting&quot;</span>] = <span class="ruby-value">2</span>] = <span class="ruby-string">&quot;waiting&quot;</span>;
<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-string">&quot;receiving&quot;</span>] = <span class="ruby-value">3</span>] = <span class="ruby-string">&quot;receiving&quot;</span>;
<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-string">&quot;stopping&quot;</span>] = <span class="ruby-value">4</span>] = <span class="ruby-string">&quot;stopping&quot;</span>;
<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-constant">FormSubmissionState</span>[<span class="ruby-string">&quot;stopped&quot;</span>] = <span class="ruby-value">5</span>] = <span class="ruby-string">&quot;stopped&quot;</span>;
</pre>

<p>})(FormSubmissionState || (FormSubmissionState = {}));</p>

<p>var FormEnctype;</p>

<p>(function(FormEnctype) {</p>

<pre class="ruby"><span class="ruby-constant">FormEnctype</span>[<span class="ruby-string">&quot;urlEncoded&quot;</span>] = <span class="ruby-string">&quot;application/x-www-form-urlencoded&quot;</span>;
<span class="ruby-constant">FormEnctype</span>[<span class="ruby-string">&quot;multipart&quot;</span>] = <span class="ruby-string">&quot;multipart/form-data&quot;</span>;
<span class="ruby-constant">FormEnctype</span>[<span class="ruby-string">&quot;plain&quot;</span>] = <span class="ruby-string">&quot;text/plain&quot;</span>;
</pre>

<p>})(FormEnctype || (FormEnctype = {}));</p>

<p>function formEnctypeFromString(encoding) {</p>

<pre>switch (encoding.toLowerCase()) {
 case FormEnctype.multipart:
  return FormEnctype.multipart;

 case FormEnctype.plain:
  return FormEnctype.plain;

 default:
  return FormEnctype.urlEncoded;
}</pre>

<p>}</p>

<p>class FormSubmission {</p>

<pre>constructor(delegate, formElement, submitter, mustRedirect = false) {
  this.state = FormSubmissionState.initialized;
  this.delegate = delegate;
  this.formElement = formElement;
  this.submitter = submitter;
  this.formData = buildFormData(formElement, submitter);
  this.location = expandURL(this.action);
  if (this.method == FetchMethod.get) {
    mergeFormDataEntries(this.location, [ ...this.body.entries() ]);
  }
  this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
  this.mustRedirect = mustRedirect;
}
static confirmMethod(message, _element, _submitter) {
  return Promise.resolve(confirm(message));
}
get method() {
  var _a;
  const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute(&quot;formmethod&quot;)) || this.formElement.getAttribute(&quot;method&quot;) || &quot;&quot;;
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
}
get action() {
  var _a;
  const formElementAction = typeof this.formElement.action === &quot;string&quot; ? this.formElement.action : null;
  if ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.hasAttribute(&quot;formaction&quot;)) {
    return this.submitter.getAttribute(&quot;formaction&quot;) || &quot;&quot;;
  } else {
    return this.formElement.getAttribute(&quot;action&quot;) || formElementAction || &quot;&quot;;
  }
}
get body() {
  if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
    return new URLSearchParams(this.stringFormData);
  } else {
    return this.formData;
  }
}
get enctype() {
  var _a;
  return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute(&quot;formenctype&quot;)) || this.formElement.enctype);
}
get isIdempotent() {
  return this.fetchRequest.isIdempotent;
}
get stringFormData() {
  return [ ...this.formData ].reduce(((entries, [name, value]) =&gt; entries.concat(typeof value == &quot;string&quot; ? [ [ name, value ] ] : [])), []);
}
async start() {
  const {initialized: initialized, requesting: requesting} = FormSubmissionState;
  const confirmationMessage = getAttribute(&quot;data-turbo-confirm&quot;, this.submitter, this.formElement);
  if (typeof confirmationMessage === &quot;string&quot;) {
    const answer = await FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
    if (!answer) {
      return;
    }
  }
  if (this.state == initialized) {
    this.state = requesting;
    return this.fetchRequest.perform();
  }
}
stop() {
  const {stopping: stopping, stopped: stopped} = FormSubmissionState;
  if (this.state != stopping &amp;&amp; this.state != stopped) {
    this.state = stopping;
    this.fetchRequest.cancel();
    return true;
  }
}
prepareHeadersForRequest(headers, request) {
  if (!request.isIdempotent) {
    const token = getCookieValue(getMetaContent(&quot;csrf-param&quot;)) || getMetaContent(&quot;csrf-token&quot;);
    if (token) {
      headers[&quot;X-CSRF-Token&quot;] = token;
    }
  }
  if (this.requestAcceptsTurboStreamResponse(request)) {
    request.acceptResponseType(StreamMessage.contentType);
  }
}
requestStarted(_request) {
  var _a;
  this.state = FormSubmissionState.waiting;
  (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute(&quot;disabled&quot;, &quot;&quot;);
  dispatch(&quot;turbo:submit-start&quot;, {
    target: this.formElement,
    detail: {
      formSubmission: this
    }
  });
  this.delegate.formSubmissionStarted(this);
}
requestPreventedHandlingResponse(request, response) {
  this.result = {
    success: response.succeeded,
    fetchResponse: response
  };
}
requestSucceededWithResponse(request, response) {
  if (response.clientError || response.serverError) {
    this.delegate.formSubmissionFailedWithResponse(this, response);
  } else if (this.requestMustRedirect(request) &amp;&amp; responseSucceededWithoutRedirect(response)) {
    const error = new Error(&quot;Form responses must redirect to another location&quot;);
    this.delegate.formSubmissionErrored(this, error);
  } else {
    this.state = FormSubmissionState.receiving;
    this.result = {
      success: true,
      fetchResponse: response
    };
    this.delegate.formSubmissionSucceededWithResponse(this, response);
  }
}
requestFailedWithResponse(request, response) {
  this.result = {
    success: false,
    fetchResponse: response
  };
  this.delegate.formSubmissionFailedWithResponse(this, response);
}
requestErrored(request, error) {
  this.result = {
    success: false,
    error: error
  };
  this.delegate.formSubmissionErrored(this, error);
}
requestFinished(_request) {
  var _a;
  this.state = FormSubmissionState.stopped;
  (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute(&quot;disabled&quot;);
  dispatch(&quot;turbo:submit-end&quot;, {
    target: this.formElement,
    detail: Object.assign({
      formSubmission: this
    }, this.result)
  });
  this.delegate.formSubmissionFinished(this);
}
requestMustRedirect(request) {
  return !request.isIdempotent &amp;&amp; this.mustRedirect;
}
requestAcceptsTurboStreamResponse(request) {
  return !request.isIdempotent || hasAttribute(&quot;data-turbo-stream&quot;, this.submitter, this.formElement);
}</pre>

<p>}</p>

<p>function buildFormData(formElement, submitter) {</p>

<pre>const formData = new FormData(formElement);
const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(&quot;name&quot;);
const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(&quot;value&quot;);
if (name) {
  formData.append(name, value || &quot;&quot;);
}
return formData;</pre>

<p>}</p>

<p>function getCookieValue(cookieName) {</p>

<pre>if (cookieName != null) {
  const cookies = document.cookie ? document.cookie.split(&quot;; &quot;) : [];
  const cookie = cookies.find((cookie =&gt; cookie.startsWith(cookieName)));
  if (cookie) {
    const value = cookie.split(&quot;=&quot;).slice(1).join(&quot;=&quot;);
    return value ? decodeURIComponent(value) : undefined;
  }
}</pre>

<p>}</p>

<p>function responseSucceededWithoutRedirect(response) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">statusCode</span> <span class="ruby-operator">==</span> <span class="ruby-value">200</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">response</span>.<span class="ruby-identifier">redirected</span>;
</pre>

<p>}</p>

<p>function mergeFormDataEntries(url, entries) {</p>

<pre>const searchParams = new URLSearchParams;
for (const [name, value] of entries) {
  if (value instanceof File) continue;
  searchParams.append(name, value);
}
url.search = searchParams.toString();
return url;</pre>

<p>}</p>

<p>class Snapshot {</p>

<pre>constructor(element) {
  this.element = element;
}
get activeElement() {
  return this.element.ownerDocument.activeElement;
}
get children() {
  return [ ...this.element.children ];
}
hasAnchor(anchor) {
  return this.getElementForAnchor(anchor) != null;
}
getElementForAnchor(anchor) {
  return anchor ? this.element.querySelector(`[id=&#39;${anchor}&#39;], a[name=&#39;${anchor}&#39;]`) : null;
}
get isConnected() {
  return this.element.isConnected;
}
get firstAutofocusableElement() {
  const inertDisabledOrHidden = &quot;[inert], :disabled, [hidden], details:not([open]), dialog:not([open])&quot;;
  for (const element of this.element.querySelectorAll(&quot;[autofocus]&quot;)) {
    if (element.closest(inertDisabledOrHidden) == null) return element; else continue;
  }
  return null;
}
get permanentElements() {
  return queryPermanentElementsAll(this.element);
}
getPermanentElementById(id) {
  return getPermanentElementById(this.element, id);
}
getPermanentElementMapForSnapshot(snapshot) {
  const permanentElementMap = {};
  for (const currentPermanentElement of this.permanentElements) {
    const {id: id} = currentPermanentElement;
    const newPermanentElement = snapshot.getPermanentElementById(id);
    if (newPermanentElement) {
      permanentElementMap[id] = [ currentPermanentElement, newPermanentElement ];
    }
  }
  return permanentElementMap;
}</pre>

<p>}</p>

<p>function getPermanentElementById(node, id) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">querySelector</span>(<span class="ruby-string">`#${id}[data-turbo-permanent]`</span>);
</pre>

<p>}</p>

<p>function queryPermanentElementsAll(node) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">querySelectorAll</span>(<span class="ruby-string">&quot;[id][data-turbo-permanent]&quot;</span>);
</pre>

<p>}</p>

<p>class FormSubmitObserver {</p>

<pre>constructor(delegate, eventTarget) {
  this.started = false;
  this.submitCaptured = () =&gt; {
    this.eventTarget.removeEventListener(&quot;submit&quot;, this.submitBubbled, false);
    this.eventTarget.addEventListener(&quot;submit&quot;, this.submitBubbled, false);
  };
  this.submitBubbled = event =&gt; {
    if (!event.defaultPrevented) {
      const form = event.target instanceof HTMLFormElement ? event.target : undefined;
      const submitter = event.submitter || undefined;
      if (form &amp;&amp; submissionDoesNotDismissDialog(form, submitter) &amp;&amp; submissionDoesNotTargetIFrame(form, submitter) &amp;&amp; this.delegate.willSubmitForm(form, submitter)) {
        event.preventDefault();
        this.delegate.formSubmitted(form, submitter);
      }
    }
  };
  this.delegate = delegate;
  this.eventTarget = eventTarget;
}
start() {
  if (!this.started) {
    this.eventTarget.addEventListener(&quot;submit&quot;, this.submitCaptured, true);
    this.started = true;
  }
}
stop() {
  if (this.started) {
    this.eventTarget.removeEventListener(&quot;submit&quot;, this.submitCaptured, true);
    this.started = false;
  }
}</pre>

<p>}</p>

<p>function submissionDoesNotDismissDialog(form, submitter) {</p>

<pre>const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(&quot;formmethod&quot;)) || form.getAttribute(&quot;method&quot;);
return method != &quot;dialog&quot;;</pre>

<p>}</p>

<p>function submissionDoesNotTargetIFrame(form, submitter) {</p>

<pre>const target = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(&quot;formtarget&quot;)) || form.target;
for (const element of document.getElementsByName(target)) {
  if (element instanceof HTMLIFrameElement) return false;
}
return true;</pre>

<p>}</p>

<p>class View {</p>

<pre>constructor(delegate, element) {
  this.resolveRenderPromise = _value =&gt; {};
  this.resolveInterceptionPromise = _value =&gt; {};
  this.delegate = delegate;
  this.element = element;
}
scrollToAnchor(anchor) {
  const element = this.snapshot.getElementForAnchor(anchor);
  if (element) {
    this.scrollToElement(element);
    this.focusElement(element);
  } else {
    this.scrollToPosition({
      x: 0,
      y: 0
    });
  }
}
scrollToAnchorFromLocation(location) {
  this.scrollToAnchor(getAnchor(location));
}
scrollToElement(element) {
  element.scrollIntoView();
}
focusElement(element) {
  if (element instanceof HTMLElement) {
    if (element.hasAttribute(&quot;tabindex&quot;)) {
      element.focus();
    } else {
      element.setAttribute(&quot;tabindex&quot;, &quot;-1&quot;);
      element.focus();
      element.removeAttribute(&quot;tabindex&quot;);
    }
  }
}
scrollToPosition({x: x, y: y}) {
  this.scrollRoot.scrollTo(x, y);
}
scrollToTop() {
  this.scrollToPosition({
    x: 0,
    y: 0
  });
}
get scrollRoot() {
  return window;
}
async render(renderer) {
  const {isPreview: isPreview, shouldRender: shouldRender, newSnapshot: snapshot} = renderer;
  if (shouldRender) {
    try {
      this.renderPromise = new Promise((resolve =&gt; this.resolveRenderPromise = resolve));
      this.renderer = renderer;
      await this.prepareToRenderSnapshot(renderer);
      const renderInterception = new Promise((resolve =&gt; this.resolveInterceptionPromise = resolve));
      const options = {
        resume: this.resolveInterceptionPromise,
        render: this.renderer.renderElement
      };
      const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
      if (!immediateRender) await renderInterception;
      await this.renderSnapshot(renderer);
      this.delegate.viewRenderedSnapshot(snapshot, isPreview);
      this.delegate.preloadOnLoadLinksForView(this.element);
      this.finishRenderingSnapshot(renderer);
    } finally {
      delete this.renderer;
      this.resolveRenderPromise(undefined);
      delete this.renderPromise;
    }
  } else {
    this.invalidate(renderer.reloadReason);
  }
}
invalidate(reason) {
  this.delegate.viewInvalidated(reason);
}
async prepareToRenderSnapshot(renderer) {
  this.markAsPreview(renderer.isPreview);
  await renderer.prepareToRender();
}
markAsPreview(isPreview) {
  if (isPreview) {
    this.element.setAttribute(&quot;data-turbo-preview&quot;, &quot;&quot;);
  } else {
    this.element.removeAttribute(&quot;data-turbo-preview&quot;);
  }
}
async renderSnapshot(renderer) {
  await renderer.render();
}
finishRenderingSnapshot(renderer) {
  renderer.finishRendering();
}</pre>

<p>}</p>

<p>class FrameView extends View {</p>

<pre class="ruby"><span class="ruby-identifier">invalidate</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">element</span>.<span class="ruby-identifier">innerHTML</span> = <span class="ruby-string">&quot;&quot;</span>;
}
<span class="ruby-identifier">get</span> <span class="ruby-identifier">snapshot</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Snapshot</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">element</span>);
}
</pre>

<p>}</p>

<p>class LinkClickObserver {</p>

<pre>constructor(delegate, eventTarget) {
  this.started = false;
  this.clickCaptured = () =&gt; {
    this.eventTarget.removeEventListener(&quot;click&quot;, this.clickBubbled, false);
    this.eventTarget.addEventListener(&quot;click&quot;, this.clickBubbled, false);
  };
  this.clickBubbled = event =&gt; {
    if (event instanceof MouseEvent &amp;&amp; this.clickEventIsSignificant(event)) {
      const target = event.composedPath &amp;&amp; event.composedPath()[0] || event.target;
      const link = this.findLinkFromClickTarget(target);
      if (link &amp;&amp; doesNotTargetIFrame(link)) {
        const location = this.getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location, event)) {
          event.preventDefault();
          this.delegate.followedLinkToLocation(link, location);
        }
      }
    }
  };
  this.delegate = delegate;
  this.eventTarget = eventTarget;
}
start() {
  if (!this.started) {
    this.eventTarget.addEventListener(&quot;click&quot;, this.clickCaptured, true);
    this.started = true;
  }
}
stop() {
  if (this.started) {
    this.eventTarget.removeEventListener(&quot;click&quot;, this.clickCaptured, true);
    this.started = false;
  }
}
clickEventIsSignificant(event) {
  return !(event.target &amp;&amp; event.target.isContentEditable || event.defaultPrevented || event.which &gt; 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
}
findLinkFromClickTarget(target) {
  if (target instanceof Element) {
    return target.closest(&quot;a[href]:not([target^=_]):not([download])&quot;);
  }
}
getLocationForLink(link) {
  return expandURL(link.getAttribute(&quot;href&quot;) || &quot;&quot;);
}</pre>

<p>}</p>

<p>function doesNotTargetIFrame(anchor) {</p>

<pre>for (const element of document.getElementsByName(anchor.target)) {
  if (element instanceof HTMLIFrameElement) return false;
}
return true;</pre>

<p>}</p>

<p>class FormLinkClickObserver {</p>

<pre>constructor(delegate, element) {
  this.delegate = delegate;
  this.linkClickObserver = new LinkClickObserver(this, element);
}
start() {
  this.linkClickObserver.start();
}
stop() {
  this.linkClickObserver.stop();
}
willFollowLinkToLocation(link, location, originalEvent) {
  return this.delegate.willSubmitFormLinkToLocation(link, location, originalEvent) &amp;&amp; link.hasAttribute(&quot;data-turbo-method&quot;);
}
followedLinkToLocation(link, location) {
  const action = location.href;
  const form = document.createElement(&quot;form&quot;);
  form.setAttribute(&quot;data-turbo&quot;, &quot;true&quot;);
  form.setAttribute(&quot;action&quot;, action);
  form.setAttribute(&quot;hidden&quot;, &quot;&quot;);
  const method = link.getAttribute(&quot;data-turbo-method&quot;);
  if (method) form.setAttribute(&quot;method&quot;, method);
  const turboFrame = link.getAttribute(&quot;data-turbo-frame&quot;);
  if (turboFrame) form.setAttribute(&quot;data-turbo-frame&quot;, turboFrame);
  const turboAction = link.getAttribute(&quot;data-turbo-action&quot;);
  if (turboAction) form.setAttribute(&quot;data-turbo-action&quot;, turboAction);
  const turboConfirm = link.getAttribute(&quot;data-turbo-confirm&quot;);
  if (turboConfirm) form.setAttribute(&quot;data-turbo-confirm&quot;, turboConfirm);
  const turboStream = link.hasAttribute(&quot;data-turbo-stream&quot;);
  if (turboStream) form.setAttribute(&quot;data-turbo-stream&quot;, &quot;&quot;);
  this.delegate.submittedFormLinkToLocation(link, location, form);
  document.body.appendChild(form);
  form.addEventListener(&quot;turbo:submit-end&quot;, (() =&gt; form.remove()), {
    once: true
  });
  requestAnimationFrame((() =&gt; form.requestSubmit()));
}</pre>

<p>}</p>

<p>class Bardo {</p>

<pre>constructor(delegate, permanentElementMap) {
  this.delegate = delegate;
  this.permanentElementMap = permanentElementMap;
}
static preservingPermanentElements(delegate, permanentElementMap, callback) {
  const bardo = new this(delegate, permanentElementMap);
  bardo.enter();
  callback();
  bardo.leave();
}
enter() {
  for (const id in this.permanentElementMap) {
    const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
    this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
    this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
  }
}
leave() {
  for (const id in this.permanentElementMap) {
    const [currentPermanentElement] = this.permanentElementMap[id];
    this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
    this.replacePlaceholderWithPermanentElement(currentPermanentElement);
    this.delegate.leavingBardo(currentPermanentElement);
  }
}
replaceNewPermanentElementWithPlaceholder(permanentElement) {
  const placeholder = createPlaceholderForPermanentElement(permanentElement);
  permanentElement.replaceWith(placeholder);
}
replaceCurrentPermanentElementWithClone(permanentElement) {
  const clone = permanentElement.cloneNode(true);
  permanentElement.replaceWith(clone);
}
replacePlaceholderWithPermanentElement(permanentElement) {
  const placeholder = this.getPlaceholderById(permanentElement.id);
  placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
}
getPlaceholderById(id) {
  return this.placeholders.find((element =&gt; element.content == id));
}
get placeholders() {
  return [ ...document.querySelectorAll(&quot;meta[name=turbo-permanent-placeholder][content]&quot;) ];
}</pre>

<p>}</p>

<p>function createPlaceholderForPermanentElement(permanentElement) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">element</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">createElement</span>(<span class="ruby-string">&quot;meta&quot;</span>);
<span class="ruby-identifier">element</span>.<span class="ruby-identifier">setAttribute</span>(<span class="ruby-string">&quot;name&quot;</span>, <span class="ruby-string">&quot;turbo-permanent-placeholder&quot;</span>);
<span class="ruby-identifier">element</span>.<span class="ruby-identifier">setAttribute</span>(<span class="ruby-string">&quot;content&quot;</span>, <span class="ruby-identifier">permanentElement</span>.<span class="ruby-identifier">id</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">element</span>;
</pre>

<p>}</p>

<p>class Renderer {</p>

<pre>constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
  this.activeElement = null;
  this.currentSnapshot = currentSnapshot;
  this.newSnapshot = newSnapshot;
  this.isPreview = isPreview;
  this.willRender = willRender;
  this.renderElement = renderElement;
  this.promise = new Promise(((resolve, reject) =&gt; this.resolvingFunctions = {
    resolve: resolve,
    reject: reject
  }));
}
get shouldRender() {
  return true;
}
get reloadReason() {
  return;
}
prepareToRender() {
  return;
}
finishRendering() {
  if (this.resolvingFunctions) {
    this.resolvingFunctions.resolve();
    delete this.resolvingFunctions;
  }
}
preservingPermanentElements(callback) {
  Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
}
focusFirstAutofocusableElement() {
  const element = this.connectedSnapshot.firstAutofocusableElement;
  if (elementIsFocusable(element)) {
    element.focus();
  }
}
enteringBardo(currentPermanentElement) {
  if (this.activeElement) return;
  if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
    this.activeElement = this.currentSnapshot.activeElement;
  }
}
leavingBardo(currentPermanentElement) {
  if (currentPermanentElement.contains(this.activeElement) &amp;&amp; this.activeElement instanceof HTMLElement) {
    this.activeElement.focus();
    this.activeElement = null;
  }
}
get connectedSnapshot() {
  return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
}
get currentElement() {
  return this.currentSnapshot.element;
}
get newElement() {
  return this.newSnapshot.element;
}
get permanentElementMap() {
  return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
}</pre>

<p>}</p>

<p>function elementIsFocusable(element) {</p>

<pre>return element &amp;&amp; typeof element.focus == &quot;function&quot;;</pre>

<p>}</p>

<p>class FrameRenderer extends Renderer {</p>

<pre>constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
  super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
  this.delegate = delegate;
}
static renderElement(currentElement, newElement) {
  var _a;
  const destinationRange = document.createRange();
  destinationRange.selectNodeContents(currentElement);
  destinationRange.deleteContents();
  const frameElement = newElement;
  const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
  if (sourceRange) {
    sourceRange.selectNodeContents(frameElement);
    currentElement.appendChild(sourceRange.extractContents());
  }
}
get shouldRender() {
  return true;
}
async render() {
  await nextAnimationFrame();
  this.preservingPermanentElements((() =&gt; {
    this.loadFrameElement();
  }));
  this.scrollFrameIntoView();
  await nextAnimationFrame();
  this.focusFirstAutofocusableElement();
  await nextAnimationFrame();
  this.activateScriptElements();
}
loadFrameElement() {
  this.delegate.willRenderFrame(this.currentElement, this.newElement);
  this.renderElement(this.currentElement, this.newElement);
}
scrollFrameIntoView() {
  if (this.currentElement.autoscroll || this.newElement.autoscroll) {
    const element = this.currentElement.firstElementChild;
    const block = readScrollLogicalPosition(this.currentElement.getAttribute(&quot;data-autoscroll-block&quot;), &quot;end&quot;);
    const behavior = readScrollBehavior(this.currentElement.getAttribute(&quot;data-autoscroll-behavior&quot;), &quot;auto&quot;);
    if (element) {
      element.scrollIntoView({
        block: block,
        behavior: behavior
      });
      return true;
    }
  }
  return false;
}
activateScriptElements() {
  for (const inertScriptElement of this.newScriptElements) {
    const activatedScriptElement = activateScriptElement(inertScriptElement);
    inertScriptElement.replaceWith(activatedScriptElement);
  }
}
get newScriptElements() {
  return this.currentElement.querySelectorAll(&quot;script&quot;);
}</pre>

<p>}</p>

<p>function readScrollLogicalPosition(value, defaultValue) {</p>

<pre>if (value == &quot;end&quot; || value == &quot;start&quot; || value == &quot;center&quot; || value == &quot;nearest&quot;) {
  return value;
} else {
  return defaultValue;
}</pre>

<p>}</p>

<p>function readScrollBehavior(value, defaultValue) {</p>

<pre>if (value == &quot;auto&quot; || value == &quot;smooth&quot;) {
  return value;
} else {
  return defaultValue;
}</pre>

<p>}</p>

<p>class ProgressBar {</p>

<pre>constructor() {
  this.hiding = false;
  this.value = 0;
  this.visible = false;
  this.trickle = () =&gt; {
    this.setValue(this.value + Math.random() / 100);
  };
  this.stylesheetElement = this.createStylesheetElement();
  this.progressElement = this.createProgressElement();
  this.installStylesheetElement();
  this.setValue(0);
}
static get defaultCSS() {
  return unindent`
    .turbo-progress-bar {
      position: fixed;
      display: block;
      top: 0;
      left: 0;
      height: 3px;
      background: #0076ff;
      z-index: 2147483647;
      transition:
        width ${ProgressBar.animationDuration}ms ease-out,
        opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
      transform: translate3d(0, 0, 0);
    }
  `;
}
show() {
  if (!this.visible) {
    this.visible = true;
    this.installProgressElement();
    this.startTrickling();
  }
}
hide() {
  if (this.visible &amp;&amp; !this.hiding) {
    this.hiding = true;
    this.fadeProgressElement((() =&gt; {
      this.uninstallProgressElement();
      this.stopTrickling();
      this.visible = false;
      this.hiding = false;
    }));
  }
}
setValue(value) {
  this.value = value;
  this.refresh();
}
installStylesheetElement() {
  document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
}
installProgressElement() {
  this.progressElement.style.width = &quot;0&quot;;
  this.progressElement.style.opacity = &quot;1&quot;;
  document.documentElement.insertBefore(this.progressElement, document.body);
  this.refresh();
}
fadeProgressElement(callback) {
  this.progressElement.style.opacity = &quot;0&quot;;
  setTimeout(callback, ProgressBar.animationDuration * 1.5);
}
uninstallProgressElement() {
  if (this.progressElement.parentNode) {
    document.documentElement.removeChild(this.progressElement);
  }
}
startTrickling() {
  if (!this.trickleInterval) {
    this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
  }
}
stopTrickling() {
  window.clearInterval(this.trickleInterval);
  delete this.trickleInterval;
}
refresh() {
  requestAnimationFrame((() =&gt; {
    this.progressElement.style.width = `${10 + this.value * 90}%`;
  }));
}
createStylesheetElement() {
  const element = document.createElement(&quot;style&quot;);
  element.type = &quot;text/css&quot;;
  element.textContent = ProgressBar.defaultCSS;
  if (this.cspNonce) {
    element.nonce = this.cspNonce;
  }
  return element;
}
createProgressElement() {
  const element = document.createElement(&quot;div&quot;);
  element.className = &quot;turbo-progress-bar&quot;;
  return element;
}
get cspNonce() {
  return getMetaContent(&quot;csp-nonce&quot;);
}</pre>

<p>}</p>

<p>ProgressBar.animationDuration = 300;</p>

<p>class HeadSnapshot extends Snapshot {</p>

<pre>constructor() {
  super(...arguments);
  this.detailsByOuterHTML = this.children.filter((element =&gt; !elementIsNoscript(element))).map((element =&gt; elementWithoutNonce(element))).reduce(((result, element) =&gt; {
    const {outerHTML: outerHTML} = element;
    const details = outerHTML in result ? result[outerHTML] : {
      type: elementType(element),
      tracked: elementIsTracked(element),
      elements: []
    };
    return Object.assign(Object.assign({}, result), {
      [outerHTML]: Object.assign(Object.assign({}, details), {
        elements: [ ...details.elements, element ]
      })
    });
  }), {});
}
get trackedElementSignature() {
  return Object.keys(this.detailsByOuterHTML).filter((outerHTML =&gt; this.detailsByOuterHTML[outerHTML].tracked)).join(&quot;&quot;);
}
getScriptElementsNotInSnapshot(snapshot) {
  return this.getElementsMatchingTypeNotInSnapshot(&quot;script&quot;, snapshot);
}
getStylesheetElementsNotInSnapshot(snapshot) {
  return this.getElementsMatchingTypeNotInSnapshot(&quot;stylesheet&quot;, snapshot);
}
getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
  return Object.keys(this.detailsByOuterHTML).filter((outerHTML =&gt; !(outerHTML in snapshot.detailsByOuterHTML))).map((outerHTML =&gt; this.detailsByOuterHTML[outerHTML])).filter((({type: type}) =&gt; type == matchedType)).map((({elements: [element]}) =&gt; element));
}
get provisionalElements() {
  return Object.keys(this.detailsByOuterHTML).reduce(((result, outerHTML) =&gt; {
    const {type: type, tracked: tracked, elements: elements} = this.detailsByOuterHTML[outerHTML];
    if (type == null &amp;&amp; !tracked) {
      return [ ...result, ...elements ];
    } else if (elements.length &gt; 1) {
      return [ ...result, ...elements.slice(1) ];
    } else {
      return result;
    }
  }), []);
}
getMetaValue(name) {
  const element = this.findMetaElementByName(name);
  return element ? element.getAttribute(&quot;content&quot;) : null;
}
findMetaElementByName(name) {
  return Object.keys(this.detailsByOuterHTML).reduce(((result, outerHTML) =&gt; {
    const {elements: [element]} = this.detailsByOuterHTML[outerHTML];
    return elementIsMetaElementWithName(element, name) ? element : result;
  }), undefined);
}</pre>

<p>}</p>

<p>function elementType(element) {</p>

<pre>if (elementIsScript(element)) {
  return &quot;script&quot;;
} else if (elementIsStylesheet(element)) {
  return &quot;stylesheet&quot;;
}</pre>

<p>}</p>

<p>function elementIsTracked(element) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&quot;data-turbo-track&quot;</span>) <span class="ruby-operator">==</span> <span class="ruby-string">&quot;reload&quot;</span>;
</pre>

<p>}</p>

<p>function elementIsScript(element) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">tagName</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">localName</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">tagName</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;script&quot;</span>;
</pre>

<p>}</p>

<p>function elementIsNoscript(element) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">tagName</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">localName</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">tagName</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;noscript&quot;</span>;
</pre>

<p>}</p>

<p>function elementIsStylesheet(element) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">tagName</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">localName</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">tagName</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;style&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tagName</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;link&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&quot;rel&quot;</span>) <span class="ruby-operator">==</span> <span class="ruby-string">&quot;stylesheet&quot;</span>;
</pre>

<p>}</p>

<p>function elementIsMetaElementWithName(element, name) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">tagName</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">localName</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">tagName</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;meta&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&quot;name&quot;</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>;
</pre>

<p>}</p>

<p>function elementWithoutNonce(element) {</p>

<pre>if (element.hasAttribute(&quot;nonce&quot;)) {
  element.setAttribute(&quot;nonce&quot;, &quot;&quot;);
}
return element;</pre>

<p>}</p>

<p>class PageSnapshot extends Snapshot {</p>

<pre>constructor(element, headSnapshot) {
  super(element);
  this.headSnapshot = headSnapshot;
}
static fromHTMLString(html = &quot;&quot;) {
  return this.fromDocument(parseHTMLDocument(html));
}
static fromElement(element) {
  return this.fromDocument(element.ownerDocument);
}
static fromDocument({head: head, body: body}) {
  return new this(body, new HeadSnapshot(head));
}
clone() {
  const clonedElement = this.element.cloneNode(true);
  const selectElements = this.element.querySelectorAll(&quot;select&quot;);
  const clonedSelectElements = clonedElement.querySelectorAll(&quot;select&quot;);
  for (const [index, source] of selectElements.entries()) {
    const clone = clonedSelectElements[index];
    for (const option of clone.selectedOptions) option.selected = false;
    for (const option of source.selectedOptions) clone.options[option.index].selected = true;
  }
  for (const clonedPasswordInput of clonedElement.querySelectorAll(&#39;input[type=&quot;password&quot;]&#39;)) {
    clonedPasswordInput.value = &quot;&quot;;
  }
  return new PageSnapshot(clonedElement, this.headSnapshot);
}
get headElement() {
  return this.headSnapshot.element;
}
get rootLocation() {
  var _a;
  const root = (_a = this.getSetting(&quot;root&quot;)) !== null &amp;&amp; _a !== void 0 ? _a : &quot;/&quot;;
  return expandURL(root);
}
get cacheControlValue() {
  return this.getSetting(&quot;cache-control&quot;);
}
get isPreviewable() {
  return this.cacheControlValue != &quot;no-preview&quot;;
}
get isCacheable() {
  return this.cacheControlValue != &quot;no-cache&quot;;
}
get isVisitable() {
  return this.getSetting(&quot;visit-control&quot;) != &quot;reload&quot;;
}
getSetting(name) {
  return this.headSnapshot.getMetaValue(`turbo-${name}`);
}</pre>

<p>}</p>

<p>var TimingMetric;</p>

<p>(function(TimingMetric) {</p>

<pre class="ruby"><span class="ruby-constant">TimingMetric</span>[<span class="ruby-string">&quot;visitStart&quot;</span>] = <span class="ruby-string">&quot;visitStart&quot;</span>;
<span class="ruby-constant">TimingMetric</span>[<span class="ruby-string">&quot;requestStart&quot;</span>] = <span class="ruby-string">&quot;requestStart&quot;</span>;
<span class="ruby-constant">TimingMetric</span>[<span class="ruby-string">&quot;requestEnd&quot;</span>] = <span class="ruby-string">&quot;requestEnd&quot;</span>;
<span class="ruby-constant">TimingMetric</span>[<span class="ruby-string">&quot;visitEnd&quot;</span>] = <span class="ruby-string">&quot;visitEnd&quot;</span>;
</pre>

<p>})(TimingMetric || (TimingMetric = {}));</p>

<p>var VisitState;</p>

<p>(function(VisitState) {</p>

<pre class="ruby"><span class="ruby-constant">VisitState</span>[<span class="ruby-string">&quot;initialized&quot;</span>] = <span class="ruby-string">&quot;initialized&quot;</span>;
<span class="ruby-constant">VisitState</span>[<span class="ruby-string">&quot;started&quot;</span>] = <span class="ruby-string">&quot;started&quot;</span>;
<span class="ruby-constant">VisitState</span>[<span class="ruby-string">&quot;canceled&quot;</span>] = <span class="ruby-string">&quot;canceled&quot;</span>;
<span class="ruby-constant">VisitState</span>[<span class="ruby-string">&quot;failed&quot;</span>] = <span class="ruby-string">&quot;failed&quot;</span>;
<span class="ruby-constant">VisitState</span>[<span class="ruby-string">&quot;completed&quot;</span>] = <span class="ruby-string">&quot;completed&quot;</span>;
</pre>

<p>})(VisitState || (VisitState = {}));</p>

<p>const defaultOptions = {</p>

<pre>action: &quot;advance&quot;,
historyChanged: false,
visitCachedSnapshot: () =&gt; {},
willRender: true,
updateHistory: true,
shouldCacheSnapshot: true,
acceptsStreamResponse: false</pre>

<p>};</p>

<p>var SystemStatusCode;</p>

<p>(function(SystemStatusCode) {</p>

<pre class="ruby"><span class="ruby-constant">SystemStatusCode</span>[<span class="ruby-constant">SystemStatusCode</span>[<span class="ruby-string">&quot;networkFailure&quot;</span>] = <span class="ruby-value">0</span>] = <span class="ruby-string">&quot;networkFailure&quot;</span>;
<span class="ruby-constant">SystemStatusCode</span>[<span class="ruby-constant">SystemStatusCode</span>[<span class="ruby-string">&quot;timeoutFailure&quot;</span>] = <span class="ruby-value">-1</span>] = <span class="ruby-string">&quot;timeoutFailure&quot;</span>;
<span class="ruby-constant">SystemStatusCode</span>[<span class="ruby-constant">SystemStatusCode</span>[<span class="ruby-string">&quot;contentTypeMismatch&quot;</span>] = <span class="ruby-value">-2</span>] = <span class="ruby-string">&quot;contentTypeMismatch&quot;</span>;
</pre>

<p>})(SystemStatusCode || (SystemStatusCode = {}));</p>

<p>class Visit {</p>

<pre>constructor(delegate, location, restorationIdentifier, options = {}) {
  this.identifier = uuid();
  this.timingMetrics = {};
  this.followedRedirect = false;
  this.historyChanged = false;
  this.scrolled = false;
  this.shouldCacheSnapshot = true;
  this.acceptsStreamResponse = false;
  this.snapshotCached = false;
  this.state = VisitState.initialized;
  this.delegate = delegate;
  this.location = location;
  this.restorationIdentifier = restorationIdentifier || uuid();
  const {action: action, historyChanged: historyChanged, referrer: referrer, snapshotHTML: snapshotHTML, response: response, visitCachedSnapshot: visitCachedSnapshot, willRender: willRender, updateHistory: updateHistory, shouldCacheSnapshot: shouldCacheSnapshot, acceptsStreamResponse: acceptsStreamResponse} = Object.assign(Object.assign({}, defaultOptions), options);
  this.action = action;
  this.historyChanged = historyChanged;
  this.referrer = referrer;
  this.snapshotHTML = snapshotHTML;
  this.response = response;
  this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
  this.visitCachedSnapshot = visitCachedSnapshot;
  this.willRender = willRender;
  this.updateHistory = updateHistory;
  this.scrolled = !willRender;
  this.shouldCacheSnapshot = shouldCacheSnapshot;
  this.acceptsStreamResponse = acceptsStreamResponse;
}
get adapter() {
  return this.delegate.adapter;
}
get view() {
  return this.delegate.view;
}
get history() {
  return this.delegate.history;
}
get restorationData() {
  return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
}
get silent() {
  return this.isSamePage;
}
start() {
  if (this.state == VisitState.initialized) {
    this.recordTimingMetric(TimingMetric.visitStart);
    this.state = VisitState.started;
    this.adapter.visitStarted(this);
    this.delegate.visitStarted(this);
  }
}
cancel() {
  if (this.state == VisitState.started) {
    if (this.request) {
      this.request.cancel();
    }
    this.cancelRender();
    this.state = VisitState.canceled;
  }
}
complete() {
  if (this.state == VisitState.started) {
    this.recordTimingMetric(TimingMetric.visitEnd);
    this.state = VisitState.completed;
    this.followRedirect();
    if (!this.followedRedirect) {
      this.adapter.visitCompleted(this);
      this.delegate.visitCompleted(this);
    }
  }
}
fail() {
  if (this.state == VisitState.started) {
    this.state = VisitState.failed;
    this.adapter.visitFailed(this);
  }
}
changeHistory() {
  var _a;
  if (!this.historyChanged &amp;&amp; this.updateHistory) {
    const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? &quot;replace&quot; : this.action;
    const method = getHistoryMethodForAction(actionForHistory);
    this.history.update(method, this.location, this.restorationIdentifier);
    this.historyChanged = true;
  }
}
issueRequest() {
  if (this.hasPreloadedResponse()) {
    this.simulateRequest();
  } else if (this.shouldIssueRequest() &amp;&amp; !this.request) {
    this.request = new FetchRequest(this, FetchMethod.get, this.location);
    this.request.perform();
  }
}
simulateRequest() {
  if (this.response) {
    this.startRequest();
    this.recordResponse();
    this.finishRequest();
  }
}
startRequest() {
  this.recordTimingMetric(TimingMetric.requestStart);
  this.adapter.visitRequestStarted(this);
}
recordResponse(response = this.response) {
  this.response = response;
  if (response) {
    const {statusCode: statusCode} = response;
    if (isSuccessful(statusCode)) {
      this.adapter.visitRequestCompleted(this);
    } else {
      this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
    }
  }
}
finishRequest() {
  this.recordTimingMetric(TimingMetric.requestEnd);
  this.adapter.visitRequestFinished(this);
}
loadResponse() {
  if (this.response) {
    const {statusCode: statusCode, responseHTML: responseHTML} = this.response;
    this.render((async () =&gt; {
      if (this.shouldCacheSnapshot) this.cacheSnapshot();
      if (this.view.renderPromise) await this.view.renderPromise;
      if (isSuccessful(statusCode) &amp;&amp; responseHTML != null) {
        await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender, this);
        this.performScroll();
        this.adapter.visitRendered(this);
        this.complete();
      } else {
        await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
        this.adapter.visitRendered(this);
        this.fail();
      }
    }));
  }
}
getCachedSnapshot() {
  const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
  if (snapshot &amp;&amp; (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
    if (this.action == &quot;restore&quot; || snapshot.isPreviewable) {
      return snapshot;
    }
  }
}
getPreloadedSnapshot() {
  if (this.snapshotHTML) {
    return PageSnapshot.fromHTMLString(this.snapshotHTML);
  }
}
hasCachedSnapshot() {
  return this.getCachedSnapshot() != null;
}
loadCachedSnapshot() {
  const snapshot = this.getCachedSnapshot();
  if (snapshot) {
    const isPreview = this.shouldIssueRequest();
    this.render((async () =&gt; {
      this.cacheSnapshot();
      if (this.isSamePage) {
        this.adapter.visitRendered(this);
      } else {
        if (this.view.renderPromise) await this.view.renderPromise;
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
        this.adapter.visitRendered(this);
        if (!isPreview) {
          this.complete();
        }
      }
    }));
  }
}
followRedirect() {
  var _a;
  if (this.redirectedToLocation &amp;&amp; !this.followedRedirect &amp;&amp; ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
    this.adapter.visitProposedToLocation(this.redirectedToLocation, {
      action: &quot;replace&quot;,
      response: this.response
    });
    this.followedRedirect = true;
  }
}
goToSamePageAnchor() {
  if (this.isSamePage) {
    this.render((async () =&gt; {
      this.cacheSnapshot();
      this.performScroll();
      this.adapter.visitRendered(this);
    }));
  }
}
prepareHeadersForRequest(headers, request) {
  if (this.acceptsStreamResponse) {
    request.acceptResponseType(StreamMessage.contentType);
  }
}
requestStarted() {
  this.startRequest();
}
requestPreventedHandlingResponse(_request, _response) {}
async requestSucceededWithResponse(request, response) {
  const responseHTML = await response.responseHTML;
  const {redirected: redirected, statusCode: statusCode} = response;
  if (responseHTML == undefined) {
    this.recordResponse({
      statusCode: SystemStatusCode.contentTypeMismatch,
      redirected: redirected
    });
  } else {
    this.redirectedToLocation = response.redirected ? response.location : undefined;
    this.recordResponse({
      statusCode: statusCode,
      responseHTML: responseHTML,
      redirected: redirected
    });
  }
}
async requestFailedWithResponse(request, response) {
  const responseHTML = await response.responseHTML;
  const {redirected: redirected, statusCode: statusCode} = response;
  if (responseHTML == undefined) {
    this.recordResponse({
      statusCode: SystemStatusCode.contentTypeMismatch,
      redirected: redirected
    });
  } else {
    this.recordResponse({
      statusCode: statusCode,
      responseHTML: responseHTML,
      redirected: redirected
    });
  }
}
requestErrored(_request, _error) {
  this.recordResponse({
    statusCode: SystemStatusCode.networkFailure,
    redirected: false
  });
}
requestFinished() {
  this.finishRequest();
}
performScroll() {
  if (!this.scrolled &amp;&amp; !this.view.forceReloaded) {
    if (this.action == &quot;restore&quot;) {
      this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
    } else {
      this.scrollToAnchor() || this.view.scrollToTop();
    }
    if (this.isSamePage) {
      this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
    }
    this.scrolled = true;
  }
}
scrollToRestoredPosition() {
  const {scrollPosition: scrollPosition} = this.restorationData;
  if (scrollPosition) {
    this.view.scrollToPosition(scrollPosition);
    return true;
  }
}
scrollToAnchor() {
  const anchor = getAnchor(this.location);
  if (anchor != null) {
    this.view.scrollToAnchor(anchor);
    return true;
  }
}
recordTimingMetric(metric) {
  this.timingMetrics[metric] = (new Date).getTime();
}
getTimingMetrics() {
  return Object.assign({}, this.timingMetrics);
}
getHistoryMethodForAction(action) {
  switch (action) {
   case &quot;replace&quot;:
    return history.replaceState;

   case &quot;advance&quot;:
   case &quot;restore&quot;:
    return history.pushState;
  }
}
hasPreloadedResponse() {
  return typeof this.response == &quot;object&quot;;
}
shouldIssueRequest() {
  if (this.isSamePage) {
    return false;
  } else if (this.action == &quot;restore&quot;) {
    return !this.hasCachedSnapshot();
  } else {
    return this.willRender;
  }
}
cacheSnapshot() {
  if (!this.snapshotCached) {
    this.view.cacheSnapshot().then((snapshot =&gt; snapshot &amp;&amp; this.visitCachedSnapshot(snapshot)));
    this.snapshotCached = true;
  }
}
async render(callback) {
  this.cancelRender();
  await new Promise((resolve =&gt; {
    this.frame = requestAnimationFrame((() =&gt; resolve()));
  }));
  await callback();
  delete this.frame;
}
cancelRender() {
  if (this.frame) {
    cancelAnimationFrame(this.frame);
    delete this.frame;
  }
}</pre>

<p>}</p>

<p>function isSuccessful(statusCode) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">statusCode</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">200</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">statusCode</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">300</span>;
</pre>

<p>}</p>

<p>class BrowserAdapter {</p>

<pre>constructor(session) {
  this.progressBar = new ProgressBar;
  this.showProgressBar = () =&gt; {
    this.progressBar.show();
  };
  this.session = session;
}
visitProposedToLocation(location, options) {
  this.navigator.startVisit(location, (options === null || options === void 0 ? void 0 : options.restorationIdentifier) || uuid(), options);
}
visitStarted(visit) {
  this.location = visit.location;
  visit.loadCachedSnapshot();
  visit.issueRequest();
  visit.goToSamePageAnchor();
}
visitRequestStarted(visit) {
  this.progressBar.setValue(0);
  if (visit.hasCachedSnapshot() || visit.action != &quot;restore&quot;) {
    this.showVisitProgressBarAfterDelay();
  } else {
    this.showProgressBar();
  }
}
visitRequestCompleted(visit) {
  visit.loadResponse();
}
visitRequestFailedWithStatusCode(visit, statusCode) {
  switch (statusCode) {
   case SystemStatusCode.networkFailure:
   case SystemStatusCode.timeoutFailure:
   case SystemStatusCode.contentTypeMismatch:
    return this.reload({
      reason: &quot;request_failed&quot;,
      context: {
        statusCode: statusCode
      }
    });

   default:
    return visit.loadResponse();
  }
}
visitRequestFinished(_visit) {
  this.progressBar.setValue(1);
  this.hideVisitProgressBar();
}
visitCompleted(_visit) {}
pageInvalidated(reason) {
  this.reload(reason);
}
visitFailed(_visit) {}
visitRendered(_visit) {}
formSubmissionStarted(_formSubmission) {
  this.progressBar.setValue(0);
  this.showFormProgressBarAfterDelay();
}
formSubmissionFinished(_formSubmission) {
  this.progressBar.setValue(1);
  this.hideFormProgressBar();
}
showVisitProgressBarAfterDelay() {
  this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
}
hideVisitProgressBar() {
  this.progressBar.hide();
  if (this.visitProgressBarTimeout != null) {
    window.clearTimeout(this.visitProgressBarTimeout);
    delete this.visitProgressBarTimeout;
  }
}
showFormProgressBarAfterDelay() {
  if (this.formProgressBarTimeout == null) {
    this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
}
hideFormProgressBar() {
  this.progressBar.hide();
  if (this.formProgressBarTimeout != null) {
    window.clearTimeout(this.formProgressBarTimeout);
    delete this.formProgressBarTimeout;
  }
}
reload(reason) {
  dispatch(&quot;turbo:reload&quot;, {
    detail: reason
  });
  if (!this.location) return;
  window.location.href = this.location.toString();
}
get navigator() {
  return this.session.navigator;
}</pre>

<p>}</p>

<p>class CacheObserver {</p>

<pre>constructor() {
  this.started = false;
  this.removeStaleElements = _event =&gt; {
    const staleElements = [ ...document.querySelectorAll(&#39;[data-turbo-cache=&quot;false&quot;]&#39;) ];
    for (const element of staleElements) {
      element.remove();
    }
  };
}
start() {
  if (!this.started) {
    this.started = true;
    addEventListener(&quot;turbo:before-cache&quot;, this.removeStaleElements, false);
  }
}
stop() {
  if (this.started) {
    this.started = false;
    removeEventListener(&quot;turbo:before-cache&quot;, this.removeStaleElements, false);
  }
}</pre>

<p>}</p>

<p>class FrameRedirector {</p>

<pre>constructor(session, element) {
  this.session = session;
  this.element = element;
  this.linkClickObserver = new LinkClickObserver(this, element);
  this.formSubmitObserver = new FormSubmitObserver(this, element);
}
start() {
  this.linkClickObserver.start();
  this.formSubmitObserver.start();
}
stop() {
  this.linkClickObserver.stop();
  this.formSubmitObserver.stop();
}
willFollowLinkToLocation(element, location, event) {
  return this.shouldRedirect(element) &amp;&amp; this.frameAllowsVisitingLocation(element, location, event);
}
followedLinkToLocation(element, url) {
  const frame = this.findFrameElement(element);
  if (frame) {
    frame.delegate.followedLinkToLocation(element, url);
  }
}
willSubmitForm(element, submitter) {
  return element.closest(&quot;turbo-frame&quot;) == null &amp;&amp; this.shouldSubmit(element, submitter) &amp;&amp; this.shouldRedirect(element, submitter);
}
formSubmitted(element, submitter) {
  const frame = this.findFrameElement(element, submitter);
  if (frame) {
    frame.delegate.formSubmitted(element, submitter);
  }
}
frameAllowsVisitingLocation(target, {href: url}, originalEvent) {
  const event = dispatch(&quot;turbo:click&quot;, {
    target: target,
    detail: {
      url: url,
      originalEvent: originalEvent
    },
    cancelable: true
  });
  return !event.defaultPrevented;
}
shouldSubmit(form, submitter) {
  var _a;
  const action = getAction(form, submitter);
  const meta = this.element.ownerDocument.querySelector(`meta[name=&quot;turbo-root&quot;]`);
  const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null &amp;&amp; _a !== void 0 ? _a : &quot;/&quot;);
  return this.shouldRedirect(form, submitter) &amp;&amp; locationIsVisitable(action, rootLocation);
}
shouldRedirect(element, submitter) {
  const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
  if (isNavigatable) {
    const frame = this.findFrameElement(element, submitter);
    return frame ? frame != element.closest(&quot;turbo-frame&quot;) : false;
  } else {
    return false;
  }
}
findFrameElement(element, submitter) {
  const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(&quot;data-turbo-frame&quot;)) || element.getAttribute(&quot;data-turbo-frame&quot;);
  if (id &amp;&amp; id != &quot;_top&quot;) {
    const frame = this.element.querySelector(`#${id}:not([disabled])`);
    if (frame instanceof FrameElement) {
      return frame;
    }
  }
}</pre>

<p>}</p>

<p>class History {</p>

<pre>constructor(delegate) {
  this.restorationIdentifier = uuid();
  this.restorationData = {};
  this.started = false;
  this.pageLoaded = false;
  this.onPopState = event =&gt; {
    if (this.shouldHandlePopState()) {
      const {turbo: turbo} = event.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const {restorationIdentifier: restorationIdentifier} = turbo;
        this.restorationIdentifier = restorationIdentifier;
        this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
      }
    }
  };
  this.onPageLoad = async _event =&gt; {
    await nextMicrotask();
    this.pageLoaded = true;
  };
  this.delegate = delegate;
}
start() {
  if (!this.started) {
    addEventListener(&quot;popstate&quot;, this.onPopState, false);
    addEventListener(&quot;load&quot;, this.onPageLoad, false);
    this.started = true;
    this.replace(new URL(window.location.href));
  }
}
stop() {
  if (this.started) {
    removeEventListener(&quot;popstate&quot;, this.onPopState, false);
    removeEventListener(&quot;load&quot;, this.onPageLoad, false);
    this.started = false;
  }
}
push(location, restorationIdentifier) {
  this.update(history.pushState, location, restorationIdentifier);
}
replace(location, restorationIdentifier) {
  this.update(history.replaceState, location, restorationIdentifier);
}
update(method, location, restorationIdentifier = uuid()) {
  const state = {
    turbo: {
      restorationIdentifier: restorationIdentifier
    }
  };
  method.call(history, state, &quot;&quot;, location.href);
  this.location = location;
  this.restorationIdentifier = restorationIdentifier;
}
getRestorationDataForIdentifier(restorationIdentifier) {
  return this.restorationData[restorationIdentifier] || {};
}
updateRestorationData(additionalData) {
  const {restorationIdentifier: restorationIdentifier} = this;
  const restorationData = this.restorationData[restorationIdentifier];
  this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
}
assumeControlOfScrollRestoration() {
  var _a;
  if (!this.previousScrollRestoration) {
    this.previousScrollRestoration = (_a = history.scrollRestoration) !== null &amp;&amp; _a !== void 0 ? _a : &quot;auto&quot;;
    history.scrollRestoration = &quot;manual&quot;;
  }
}
relinquishControlOfScrollRestoration() {
  if (this.previousScrollRestoration) {
    history.scrollRestoration = this.previousScrollRestoration;
    delete this.previousScrollRestoration;
  }
}
shouldHandlePopState() {
  return this.pageIsLoaded();
}
pageIsLoaded() {
  return this.pageLoaded || document.readyState == &quot;complete&quot;;
}</pre>

<p>}</p>

<p>class Navigator {</p>

<pre>constructor(delegate) {
  this.delegate = delegate;
}
proposeVisit(location, options = {}) {
  if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {
    if (locationIsVisitable(location, this.view.snapshot.rootLocation)) {
      this.delegate.visitProposedToLocation(location, options);
    } else {
      window.location.href = location.toString();
    }
  }
}
startVisit(locatable, restorationIdentifier, options = {}) {
  this.lastVisit = this.currentVisit;
  this.stop();
  this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({
    referrer: this.location
  }, options));
  this.currentVisit.start();
}
submitForm(form, submitter) {
  this.stop();
  this.formSubmission = new FormSubmission(this, form, submitter, true);
  this.formSubmission.start();
}
stop() {
  if (this.formSubmission) {
    this.formSubmission.stop();
    delete this.formSubmission;
  }
  if (this.currentVisit) {
    this.currentVisit.cancel();
    delete this.currentVisit;
  }
}
get adapter() {
  return this.delegate.adapter;
}
get view() {
  return this.delegate.view;
}
get history() {
  return this.delegate.history;
}
formSubmissionStarted(formSubmission) {
  if (typeof this.adapter.formSubmissionStarted === &quot;function&quot;) {
    this.adapter.formSubmissionStarted(formSubmission);
  }
}
async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
  if (formSubmission == this.formSubmission) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const shouldCacheSnapshot = formSubmission.method == FetchMethod.get;
      if (!shouldCacheSnapshot) {
        this.view.clearSnapshotCache();
      }
      const {statusCode: statusCode, redirected: redirected} = fetchResponse;
      const action = this.getActionForFormSubmission(formSubmission);
      const visitOptions = {
        action: action,
        shouldCacheSnapshot: shouldCacheSnapshot,
        response: {
          statusCode: statusCode,
          responseHTML: responseHTML,
          redirected: redirected
        }
      };
      this.proposeVisit(fetchResponse.location, visitOptions);
    }
  }
}
async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
  const responseHTML = await fetchResponse.responseHTML;
  if (responseHTML) {
    const snapshot = PageSnapshot.fromHTMLString(responseHTML);
    if (fetchResponse.serverError) {
      await this.view.renderError(snapshot, this.currentVisit);
    } else {
      await this.view.renderPage(snapshot, false, true, this.currentVisit);
    }
    this.view.scrollToTop();
    this.view.clearSnapshotCache();
  }
}
formSubmissionErrored(formSubmission, error) {
  console.error(error);
}
formSubmissionFinished(formSubmission) {
  if (typeof this.adapter.formSubmissionFinished === &quot;function&quot;) {
    this.adapter.formSubmissionFinished(formSubmission);
  }
}
visitStarted(visit) {
  this.delegate.visitStarted(visit);
}
visitCompleted(visit) {
  this.delegate.visitCompleted(visit);
}
locationWithActionIsSamePage(location, action) {
  var _a;
  const anchor = getAnchor(location);
  const lastLocation = ((_a = this.lastVisit) === null || _a === void 0 ? void 0 : _a.location) || this.view.lastRenderedLocation;
  const currentAnchor = getAnchor(lastLocation);
  const isRestorationToTop = action === &quot;restore&quot; &amp;&amp; typeof anchor === &quot;undefined&quot;;
  return action !== &quot;replace&quot; &amp;&amp; getRequestURL(location) === getRequestURL(lastLocation) &amp;&amp; (isRestorationToTop || anchor != null &amp;&amp; anchor !== currentAnchor);
}
visitScrolledToSamePageLocation(oldURL, newURL) {
  this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
}
get location() {
  return this.history.location;
}
get restorationIdentifier() {
  return this.history.restorationIdentifier;
}
getActionForFormSubmission(formSubmission) {
  const {formElement: formElement, submitter: submitter} = formSubmission;
  const action = getAttribute(&quot;data-turbo-action&quot;, submitter, formElement);
  return isAction(action) ? action : &quot;advance&quot;;
}</pre>

<p>}</p>

<p>var PageStage;</p>

<p>(function(PageStage) {</p>

<pre class="ruby"><span class="ruby-constant">PageStage</span>[<span class="ruby-constant">PageStage</span>[<span class="ruby-string">&quot;initial&quot;</span>] = <span class="ruby-value">0</span>] = <span class="ruby-string">&quot;initial&quot;</span>;
<span class="ruby-constant">PageStage</span>[<span class="ruby-constant">PageStage</span>[<span class="ruby-string">&quot;loading&quot;</span>] = <span class="ruby-value">1</span>] = <span class="ruby-string">&quot;loading&quot;</span>;
<span class="ruby-constant">PageStage</span>[<span class="ruby-constant">PageStage</span>[<span class="ruby-string">&quot;interactive&quot;</span>] = <span class="ruby-value">2</span>] = <span class="ruby-string">&quot;interactive&quot;</span>;
<span class="ruby-constant">PageStage</span>[<span class="ruby-constant">PageStage</span>[<span class="ruby-string">&quot;complete&quot;</span>] = <span class="ruby-value">3</span>] = <span class="ruby-string">&quot;complete&quot;</span>;
</pre>

<p>})(PageStage || (PageStage = {}));</p>

<p>class PageObserver {</p>

<pre>constructor(delegate) {
  this.stage = PageStage.initial;
  this.started = false;
  this.interpretReadyState = () =&gt; {
    const {readyState: readyState} = this;
    if (readyState == &quot;interactive&quot;) {
      this.pageIsInteractive();
    } else if (readyState == &quot;complete&quot;) {
      this.pageIsComplete();
    }
  };
  this.pageWillUnload = () =&gt; {
    this.delegate.pageWillUnload();
  };
  this.delegate = delegate;
}
start() {
  if (!this.started) {
    if (this.stage == PageStage.initial) {
      this.stage = PageStage.loading;
    }
    document.addEventListener(&quot;readystatechange&quot;, this.interpretReadyState, false);
    addEventListener(&quot;pagehide&quot;, this.pageWillUnload, false);
    this.started = true;
  }
}
stop() {
  if (this.started) {
    document.removeEventListener(&quot;readystatechange&quot;, this.interpretReadyState, false);
    removeEventListener(&quot;pagehide&quot;, this.pageWillUnload, false);
    this.started = false;
  }
}
pageIsInteractive() {
  if (this.stage == PageStage.loading) {
    this.stage = PageStage.interactive;
    this.delegate.pageBecameInteractive();
  }
}
pageIsComplete() {
  this.pageIsInteractive();
  if (this.stage == PageStage.interactive) {
    this.stage = PageStage.complete;
    this.delegate.pageLoaded();
  }
}
get readyState() {
  return document.readyState;
}</pre>

<p>}</p>

<p>class ScrollObserver {</p>

<pre>constructor(delegate) {
  this.started = false;
  this.onScroll = () =&gt; {
    this.updatePosition({
      x: window.pageXOffset,
      y: window.pageYOffset
    });
  };
  this.delegate = delegate;
}
start() {
  if (!this.started) {
    addEventListener(&quot;scroll&quot;, this.onScroll, false);
    this.onScroll();
    this.started = true;
  }
}
stop() {
  if (this.started) {
    removeEventListener(&quot;scroll&quot;, this.onScroll, false);
    this.started = false;
  }
}
updatePosition(position) {
  this.delegate.scrollPositionChanged(position);
}</pre>

<p>}</p>

<p>class StreamMessageRenderer {</p>

<pre>render({fragment: fragment}) {
  Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), (() =&gt; document.documentElement.appendChild(fragment)));
}
enteringBardo(currentPermanentElement, newPermanentElement) {
  newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
}
leavingBardo() {}</pre>

<p>}</p>

<p>function getPermanentElementMapForFragment(fragment) {</p>

<pre>const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
const permanentElementMap = {};
for (const permanentElementInDocument of permanentElementsInDocument) {
  const {id: id} = permanentElementInDocument;
  for (const streamElement of fragment.querySelectorAll(&quot;turbo-stream&quot;)) {
    const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
    if (elementInStream) {
      permanentElementMap[id] = [ permanentElementInDocument, elementInStream ];
    }
  }
}
return permanentElementMap;</pre>

<p>}</p>

<p>class StreamObserver {</p>

<pre>constructor(delegate) {
  this.sources = new Set;
  this.started = false;
  this.inspectFetchResponse = event =&gt; {
    const response = fetchResponseFromEvent(event);
    if (response &amp;&amp; fetchResponseIsStream(response)) {
      event.preventDefault();
      this.receiveMessageResponse(response);
    }
  };
  this.receiveMessageEvent = event =&gt; {
    if (this.started &amp;&amp; typeof event.data == &quot;string&quot;) {
      this.receiveMessageHTML(event.data);
    }
  };
  this.delegate = delegate;
}
start() {
  if (!this.started) {
    this.started = true;
    addEventListener(&quot;turbo:before-fetch-response&quot;, this.inspectFetchResponse, false);
  }
}
stop() {
  if (this.started) {
    this.started = false;
    removeEventListener(&quot;turbo:before-fetch-response&quot;, this.inspectFetchResponse, false);
  }
}
connectStreamSource(source) {
  if (!this.streamSourceIsConnected(source)) {
    this.sources.add(source);
    source.addEventListener(&quot;message&quot;, this.receiveMessageEvent, false);
  }
}
disconnectStreamSource(source) {
  if (this.streamSourceIsConnected(source)) {
    this.sources.delete(source);
    source.removeEventListener(&quot;message&quot;, this.receiveMessageEvent, false);
  }
}
streamSourceIsConnected(source) {
  return this.sources.has(source);
}
async receiveMessageResponse(response) {
  const html = await response.responseHTML;
  if (html) {
    this.receiveMessageHTML(html);
  }
}
receiveMessageHTML(html) {
  this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
}</pre>

<p>}</p>

<p>function fetchResponseFromEvent(event) {</p>

<pre>var _a;
const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
if (fetchResponse instanceof FetchResponse) {
  return fetchResponse;
}</pre>

<p>}</p>

<p>function fetchResponseIsStream(response) {</p>

<pre>var _a;
const contentType = (_a = response.contentType) !== null &amp;&amp; _a !== void 0 ? _a : &quot;&quot;;
return contentType.startsWith(StreamMessage.contentType);</pre>

<p>}</p>

<p>class ErrorRenderer extends Renderer {</p>

<pre>static renderElement(currentElement, newElement) {
  const {documentElement: documentElement, body: body} = document;
  documentElement.replaceChild(newElement, body);
}
async render() {
  this.replaceHeadAndBody();
  this.activateScriptElements();
}
replaceHeadAndBody() {
  const {documentElement: documentElement, head: head} = document;
  documentElement.replaceChild(this.newHead, head);
  this.renderElement(this.currentElement, this.newElement);
}
activateScriptElements() {
  for (const replaceableElement of this.scriptElements) {
    const parentNode = replaceableElement.parentNode;
    if (parentNode) {
      const element = activateScriptElement(replaceableElement);
      parentNode.replaceChild(element, replaceableElement);
    }
  }
}
get newHead() {
  return this.newSnapshot.headSnapshot.element;
}
get scriptElements() {
  return document.documentElement.querySelectorAll(&quot;script&quot;);
}</pre>

<p>}</p>

<p>class PageRenderer extends Renderer {</p>

<pre>static renderElement(currentElement, newElement) {
  if (document.body &amp;&amp; newElement instanceof HTMLBodyElement) {
    document.body.replaceWith(newElement);
  } else {
    document.documentElement.appendChild(newElement);
  }
}
get shouldRender() {
  return this.newSnapshot.isVisitable &amp;&amp; this.trackedElementsAreIdentical;
}
get reloadReason() {
  if (!this.newSnapshot.isVisitable) {
    return {
      reason: &quot;turbo_visit_control_is_reload&quot;
    };
  }
  if (!this.trackedElementsAreIdentical) {
    return {
      reason: &quot;tracked_element_mismatch&quot;
    };
  }
}
async prepareToRender() {
  await this.mergeHead();
}
async render() {
  if (this.willRender) {
    this.replaceBody();
  }
}
finishRendering() {
  super.finishRendering();
  if (!this.isPreview) {
    this.focusFirstAutofocusableElement();
  }
}
get currentHeadSnapshot() {
  return this.currentSnapshot.headSnapshot;
}
get newHeadSnapshot() {
  return this.newSnapshot.headSnapshot;
}
get newElement() {
  return this.newSnapshot.element;
}
async mergeHead() {
  const newStylesheetElements = this.copyNewHeadStylesheetElements();
  this.copyNewHeadScriptElements();
  this.removeCurrentHeadProvisionalElements();
  this.copyNewHeadProvisionalElements();
  await newStylesheetElements;
}
replaceBody() {
  this.preservingPermanentElements((() =&gt; {
    this.activateNewBody();
    this.assignNewBody();
  }));
}
get trackedElementsAreIdentical() {
  return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
}
async copyNewHeadStylesheetElements() {
  const loadingElements = [];
  for (const element of this.newHeadStylesheetElements) {
    loadingElements.push(waitForLoad(element));
    document.head.appendChild(element);
  }
  await Promise.all(loadingElements);
}
copyNewHeadScriptElements() {
  for (const element of this.newHeadScriptElements) {
    document.head.appendChild(activateScriptElement(element));
  }
}
removeCurrentHeadProvisionalElements() {
  for (const element of this.currentHeadProvisionalElements) {
    document.head.removeChild(element);
  }
}
copyNewHeadProvisionalElements() {
  for (const element of this.newHeadProvisionalElements) {
    document.head.appendChild(element);
  }
}
activateNewBody() {
  document.adoptNode(this.newElement);
  this.activateNewBodyScriptElements();
}
activateNewBodyScriptElements() {
  for (const inertScriptElement of this.newBodyScriptElements) {
    const activatedScriptElement = activateScriptElement(inertScriptElement);
    inertScriptElement.replaceWith(activatedScriptElement);
  }
}
assignNewBody() {
  this.renderElement(this.currentElement, this.newElement);
}
get newHeadStylesheetElements() {
  return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
}
get newHeadScriptElements() {
  return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
}
get currentHeadProvisionalElements() {
  return this.currentHeadSnapshot.provisionalElements;
}
get newHeadProvisionalElements() {
  return this.newHeadSnapshot.provisionalElements;
}
get newBodyScriptElements() {
  return this.newElement.querySelectorAll(&quot;script&quot;);
}</pre>

<p>}</p>

<p>class SnapshotCache {</p>

<pre>constructor(size) {
  this.keys = [];
  this.snapshots = {};
  this.size = size;
}
has(location) {
  return toCacheKey(location) in this.snapshots;
}
get(location) {
  if (this.has(location)) {
    const snapshot = this.read(location);
    this.touch(location);
    return snapshot;
  }
}
put(location, snapshot) {
  this.write(location, snapshot);
  this.touch(location);
  return snapshot;
}
clear() {
  this.snapshots = {};
}
read(location) {
  return this.snapshots[toCacheKey(location)];
}
write(location, snapshot) {
  this.snapshots[toCacheKey(location)] = snapshot;
}
touch(location) {
  const key = toCacheKey(location);
  const index = this.keys.indexOf(key);
  if (index &gt; -1) this.keys.splice(index, 1);
  this.keys.unshift(key);
  this.trim();
}
trim() {
  for (const key of this.keys.splice(this.size)) {
    delete this.snapshots[key];
  }
}</pre>

<p>}</p>

<p>class PageView extends View {</p>

<pre>constructor() {
  super(...arguments);
  this.snapshotCache = new SnapshotCache(10);
  this.lastRenderedLocation = new URL(location.href);
  this.forceReloaded = false;
}
renderPage(snapshot, isPreview = false, willRender = true, visit) {
  const renderer = new PageRenderer(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
  if (!renderer.shouldRender) {
    this.forceReloaded = true;
  } else {
    visit === null || visit === void 0 ? void 0 : visit.changeHistory();
  }
  return this.render(renderer);
}
renderError(snapshot, visit) {
  visit === null || visit === void 0 ? void 0 : visit.changeHistory();
  const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
  return this.render(renderer);
}
clearSnapshotCache() {
  this.snapshotCache.clear();
}
async cacheSnapshot() {
  if (this.shouldCacheSnapshot) {
    this.delegate.viewWillCacheSnapshot();
    const {snapshot: snapshot, lastRenderedLocation: location} = this;
    await nextEventLoopTick();
    const cachedSnapshot = snapshot.clone();
    this.snapshotCache.put(location, cachedSnapshot);
    return cachedSnapshot;
  }
}
getCachedSnapshotForLocation(location) {
  return this.snapshotCache.get(location);
}
get snapshot() {
  return PageSnapshot.fromElement(this.element);
}
get shouldCacheSnapshot() {
  return this.snapshot.isCacheable;
}</pre>

<p>}</p>

<p>class Preloader {</p>

<pre>constructor(delegate) {
  this.selector = &quot;a[data-turbo-preload]&quot;;
  this.delegate = delegate;
}
get snapshotCache() {
  return this.delegate.navigator.view.snapshotCache;
}
start() {
  if (document.readyState === &quot;loading&quot;) {
    return document.addEventListener(&quot;DOMContentLoaded&quot;, (() =&gt; {
      this.preloadOnLoadLinksForView(document.body);
    }));
  } else {
    this.preloadOnLoadLinksForView(document.body);
  }
}
preloadOnLoadLinksForView(element) {
  for (const link of element.querySelectorAll(this.selector)) {
    this.preloadURL(link);
  }
}
async preloadURL(link) {
  const location = new URL(link.href);
  if (this.snapshotCache.has(location)) {
    return;
  }
  try {
    const response = await fetch(location.toString(), {
      headers: {
        &quot;VND.PREFETCH&quot;: &quot;true&quot;,
        Accept: &quot;text/html&quot;
      }
    });
    const responseText = await response.text();
    const snapshot = PageSnapshot.fromHTMLString(responseText);
    this.snapshotCache.put(location, snapshot);
  } catch (_) {}
}</pre>

<p>}</p>

<p>class Session {</p>

<pre>constructor() {
  this.navigator = new Navigator(this);
  this.history = new History(this);
  this.preloader = new Preloader(this);
  this.view = new PageView(this, document.documentElement);
  this.adapter = new BrowserAdapter(this);
  this.pageObserver = new PageObserver(this);
  this.cacheObserver = new CacheObserver;
  this.linkClickObserver = new LinkClickObserver(this, window);
  this.formSubmitObserver = new FormSubmitObserver(this, document);
  this.scrollObserver = new ScrollObserver(this);
  this.streamObserver = new StreamObserver(this);
  this.formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
  this.frameRedirector = new FrameRedirector(this, document.documentElement);
  this.streamMessageRenderer = new StreamMessageRenderer;
  this.drive = true;
  this.enabled = true;
  this.progressBarDelay = 500;
  this.started = false;
  this.formMode = &quot;on&quot;;
}
start() {
  if (!this.started) {
    this.pageObserver.start();
    this.cacheObserver.start();
    this.formLinkClickObserver.start();
    this.linkClickObserver.start();
    this.formSubmitObserver.start();
    this.scrollObserver.start();
    this.streamObserver.start();
    this.frameRedirector.start();
    this.history.start();
    this.preloader.start();
    this.started = true;
    this.enabled = true;
  }
}
disable() {
  this.enabled = false;
}
stop() {
  if (this.started) {
    this.pageObserver.stop();
    this.cacheObserver.stop();
    this.formLinkClickObserver.stop();
    this.linkClickObserver.stop();
    this.formSubmitObserver.stop();
    this.scrollObserver.stop();
    this.streamObserver.stop();
    this.frameRedirector.stop();
    this.history.stop();
    this.started = false;
  }
}
registerAdapter(adapter) {
  this.adapter = adapter;
}
visit(location, options = {}) {
  const frameElement = options.frame ? document.getElementById(options.frame) : null;
  if (frameElement instanceof FrameElement) {
    frameElement.src = location.toString();
    frameElement.loaded;
  } else {
    this.navigator.proposeVisit(expandURL(location), options);
  }
}
connectStreamSource(source) {
  this.streamObserver.connectStreamSource(source);
}
disconnectStreamSource(source) {
  this.streamObserver.disconnectStreamSource(source);
}
renderStreamMessage(message) {
  this.streamMessageRenderer.render(StreamMessage.wrap(message));
}
clearCache() {
  this.view.clearSnapshotCache();
}
setProgressBarDelay(delay) {
  this.progressBarDelay = delay;
}
setFormMode(mode) {
  this.formMode = mode;
}
get location() {
  return this.history.location;
}
get restorationIdentifier() {
  return this.history.restorationIdentifier;
}
historyPoppedToLocationWithRestorationIdentifier(location, restorationIdentifier) {
  if (this.enabled) {
    this.navigator.startVisit(location, restorationIdentifier, {
      action: &quot;restore&quot;,
      historyChanged: true
    });
  } else {
    this.adapter.pageInvalidated({
      reason: &quot;turbo_disabled&quot;
    });
  }
}
scrollPositionChanged(position) {
  this.history.updateRestorationData({
    scrollPosition: position
  });
}
willSubmitFormLinkToLocation(link, location) {
  return this.elementIsNavigatable(link) &amp;&amp; locationIsVisitable(location, this.snapshot.rootLocation);
}
submittedFormLinkToLocation() {}
willFollowLinkToLocation(link, location, event) {
  return this.elementIsNavigatable(link) &amp;&amp; locationIsVisitable(location, this.snapshot.rootLocation) &amp;&amp; this.applicationAllowsFollowingLinkToLocation(link, location, event);
}
followedLinkToLocation(link, location) {
  const action = this.getActionForLink(link);
  const acceptsStreamResponse = link.hasAttribute(&quot;data-turbo-stream&quot;);
  this.visit(location.href, {
    action: action,
    acceptsStreamResponse: acceptsStreamResponse
  });
}
allowsVisitingLocationWithAction(location, action) {
  return this.locationWithActionIsSamePage(location, action) || this.applicationAllowsVisitingLocation(location);
}
visitProposedToLocation(location, options) {
  extendURLWithDeprecatedProperties(location);
  this.adapter.visitProposedToLocation(location, options);
}
visitStarted(visit) {
  if (!visit.acceptsStreamResponse) {
    markAsBusy(document.documentElement);
  }
  extendURLWithDeprecatedProperties(visit.location);
  if (!visit.silent) {
    this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);
  }
}
visitCompleted(visit) {
  clearBusyState(document.documentElement);
  this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());
}
locationWithActionIsSamePage(location, action) {
  return this.navigator.locationWithActionIsSamePage(location, action);
}
visitScrolledToSamePageLocation(oldURL, newURL) {
  this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
}
willSubmitForm(form, submitter) {
  const action = getAction(form, submitter);
  return this.submissionIsNavigatable(form, submitter) &amp;&amp; locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
}
formSubmitted(form, submitter) {
  this.navigator.submitForm(form, submitter);
}
pageBecameInteractive() {
  this.view.lastRenderedLocation = this.location;
  this.notifyApplicationAfterPageLoad();
}
pageLoaded() {
  this.history.assumeControlOfScrollRestoration();
}
pageWillUnload() {
  this.history.relinquishControlOfScrollRestoration();
}
receivedMessageFromStream(message) {
  this.renderStreamMessage(message);
}
viewWillCacheSnapshot() {
  var _a;
  if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
    this.notifyApplicationBeforeCachingSnapshot();
  }
}
allowsImmediateRender({element: element}, options) {
  const event = this.notifyApplicationBeforeRender(element, options);
  const {defaultPrevented: defaultPrevented, detail: {render: render}} = event;
  if (this.view.renderer &amp;&amp; render) {
    this.view.renderer.renderElement = render;
  }
  return !defaultPrevented;
}
viewRenderedSnapshot(_snapshot, _isPreview) {
  this.view.lastRenderedLocation = this.history.location;
  this.notifyApplicationAfterRender();
}
preloadOnLoadLinksForView(element) {
  this.preloader.preloadOnLoadLinksForView(element);
}
viewInvalidated(reason) {
  this.adapter.pageInvalidated(reason);
}
frameLoaded(frame) {
  this.notifyApplicationAfterFrameLoad(frame);
}
frameRendered(fetchResponse, frame) {
  this.notifyApplicationAfterFrameRender(fetchResponse, frame);
}
applicationAllowsFollowingLinkToLocation(link, location, ev) {
  const event = this.notifyApplicationAfterClickingLinkToLocation(link, location, ev);
  return !event.defaultPrevented;
}
applicationAllowsVisitingLocation(location) {
  const event = this.notifyApplicationBeforeVisitingLocation(location);
  return !event.defaultPrevented;
}
notifyApplicationAfterClickingLinkToLocation(link, location, event) {
  return dispatch(&quot;turbo:click&quot;, {
    target: link,
    detail: {
      url: location.href,
      originalEvent: event
    },
    cancelable: true
  });
}
notifyApplicationBeforeVisitingLocation(location) {
  return dispatch(&quot;turbo:before-visit&quot;, {
    detail: {
      url: location.href
    },
    cancelable: true
  });
}
notifyApplicationAfterVisitingLocation(location, action) {
  return dispatch(&quot;turbo:visit&quot;, {
    detail: {
      url: location.href,
      action: action
    }
  });
}
notifyApplicationBeforeCachingSnapshot() {
  return dispatch(&quot;turbo:before-cache&quot;);
}
notifyApplicationBeforeRender(newBody, options) {
  return dispatch(&quot;turbo:before-render&quot;, {
    detail: Object.assign({
      newBody: newBody
    }, options),
    cancelable: true
  });
}
notifyApplicationAfterRender() {
  return dispatch(&quot;turbo:render&quot;);
}
notifyApplicationAfterPageLoad(timing = {}) {
  return dispatch(&quot;turbo:load&quot;, {
    detail: {
      url: this.location.href,
      timing: timing
    }
  });
}
notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
  dispatchEvent(new HashChangeEvent(&quot;hashchange&quot;, {
    oldURL: oldURL.toString(),
    newURL: newURL.toString()
  }));
}
notifyApplicationAfterFrameLoad(frame) {
  return dispatch(&quot;turbo:frame-load&quot;, {
    target: frame
  });
}
notifyApplicationAfterFrameRender(fetchResponse, frame) {
  return dispatch(&quot;turbo:frame-render&quot;, {
    detail: {
      fetchResponse: fetchResponse
    },
    target: frame,
    cancelable: true
  });
}
submissionIsNavigatable(form, submitter) {
  if (this.formMode == &quot;off&quot;) {
    return false;
  } else {
    const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
    if (this.formMode == &quot;optin&quot;) {
      return submitterIsNavigatable &amp;&amp; form.closest(&#39;[data-turbo=&quot;true&quot;]&#39;) != null;
    } else {
      return submitterIsNavigatable &amp;&amp; this.elementIsNavigatable(form);
    }
  }
}
elementIsNavigatable(element) {
  const container = element.closest(&quot;[data-turbo]&quot;);
  const withinFrame = element.closest(&quot;turbo-frame&quot;);
  if (this.drive || withinFrame) {
    if (container) {
      return container.getAttribute(&quot;data-turbo&quot;) != &quot;false&quot;;
    } else {
      return true;
    }
  } else {
    if (container) {
      return container.getAttribute(&quot;data-turbo&quot;) == &quot;true&quot;;
    } else {
      return false;
    }
  }
}
getActionForLink(link) {
  const action = link.getAttribute(&quot;data-turbo-action&quot;);
  return isAction(action) ? action : &quot;advance&quot;;
}
get snapshot() {
  return this.view.snapshot;
}</pre>

<p>}</p>

<p>function extendURLWithDeprecatedProperties(url) {</p>

<pre class="ruby"><span class="ruby-constant">Object</span>.<span class="ruby-identifier">defineProperties</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">deprecatedLocationPropertyDescriptors</span>);
</pre>

<p>}</p>

<p>const deprecatedLocationPropertyDescriptors = {</p>

<pre>absoluteURL: {
  get() {
    return this.toString();
  }
}</pre>

<p>};</p>

<p>class Cache {</p>

<pre class="ruby"><span class="ruby-identifier">constructor</span>(<span class="ruby-identifier">session</span>) {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">session</span> = <span class="ruby-identifier">session</span>;
}
<span class="ruby-identifier">clear</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">session</span>.<span class="ruby-identifier">clearCache</span>();
}
<span class="ruby-identifier">resetCacheControl</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">setCacheControl</span>(<span class="ruby-string">&quot;&quot;</span>);
}
<span class="ruby-identifier">exemptPageFromCache</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">setCacheControl</span>(<span class="ruby-string">&quot;no-cache&quot;</span>);
}
<span class="ruby-identifier">exemptPageFromPreview</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">setCacheControl</span>(<span class="ruby-string">&quot;no-preview&quot;</span>);
}
<span class="ruby-identifier">setCacheControl</span>(<span class="ruby-identifier">value</span>) {
  <span class="ruby-identifier">setMetaContent</span>(<span class="ruby-string">&quot;turbo-cache-control&quot;</span>, <span class="ruby-identifier">value</span>);
}
</pre>

<p>}</p>

<p>const StreamActions = {</p>

<pre>after() {
  this.targetElements.forEach((e =&gt; {
    var _a;
    return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling);
  }));
},
append() {
  this.removeDuplicateTargetChildren();
  this.targetElements.forEach((e =&gt; e.append(this.templateContent)));
},
before() {
  this.targetElements.forEach((e =&gt; {
    var _a;
    return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e);
  }));
},
prepend() {
  this.removeDuplicateTargetChildren();
  this.targetElements.forEach((e =&gt; e.prepend(this.templateContent)));
},
remove() {
  this.targetElements.forEach((e =&gt; e.remove()));
},
replace() {
  this.targetElements.forEach((e =&gt; e.replaceWith(this.templateContent)));
},
update() {
  this.targetElements.forEach((e =&gt; e.replaceChildren(this.templateContent)));
}</pre>

<p>};</p>

<p>const session = new Session;</p>

<p>const cache = new Cache(session);</p>

<p>const {navigator: navigator$1} = session;</p>

<p>function start() {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">start</span>();
</pre>

<p>}</p>

<p>function registerAdapter(adapter) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">registerAdapter</span>(<span class="ruby-identifier">adapter</span>);
</pre>

<p>}</p>

<p>function visit(location, options) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">visit</span>(<span class="ruby-identifier">location</span>, <span class="ruby-identifier">options</span>);
</pre>

<p>}</p>

<p>function connectStreamSource(source) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">connectStreamSource</span>(<span class="ruby-identifier">source</span>);
</pre>

<p>}</p>

<p>function disconnectStreamSource(source) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">disconnectStreamSource</span>(<span class="ruby-identifier">source</span>);
</pre>

<p>}</p>

<p>function renderStreamMessage(message) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">renderStreamMessage</span>(<span class="ruby-identifier">message</span>);
</pre>

<p>}</p>

<p>function clearCache() {</p>

<pre class="ruby"><span class="ruby-identifier">console</span>.<span class="ruby-identifier">warn</span>(<span class="ruby-string">&quot;Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`&quot;</span>);
<span class="ruby-identifier">session</span>.<span class="ruby-identifier">clearCache</span>();
</pre>

<p>}</p>

<p>function setProgressBarDelay(delay) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">setProgressBarDelay</span>(<span class="ruby-identifier">delay</span>);
</pre>

<p>}</p>

<p>function setConfirmMethod(confirmMethod) {</p>

<pre class="ruby"><span class="ruby-constant">FormSubmission</span>.<span class="ruby-identifier">confirmMethod</span> = <span class="ruby-identifier">confirmMethod</span>;
</pre>

<p>}</p>

<p>function setFormMode(mode) {</p>

<pre class="ruby"><span class="ruby-identifier">session</span>.<span class="ruby-identifier">setFormMode</span>(<span class="ruby-identifier">mode</span>);
</pre>

<p>}</p>

<p>var Turbo = Object.freeze({</p>

<pre>__proto__: null,
navigator: navigator$1,
session: session,
cache: cache,
PageRenderer: PageRenderer,
PageSnapshot: PageSnapshot,
FrameRenderer: FrameRenderer,
start: start,
registerAdapter: registerAdapter,
visit: visit,
connectStreamSource: connectStreamSource,
disconnectStreamSource: disconnectStreamSource,
renderStreamMessage: renderStreamMessage,
clearCache: clearCache,
setProgressBarDelay: setProgressBarDelay,
setConfirmMethod: setConfirmMethod,
setFormMode: setFormMode,
StreamActions: StreamActions</pre>

<p>});</p>

<p>class FrameController {</p>

<pre>constructor(element) {
  this.fetchResponseLoaded = _fetchResponse =&gt; {};
  this.currentFetchRequest = null;
  this.resolveVisitPromise = () =&gt; {};
  this.connected = false;
  this.hasBeenLoaded = false;
  this.ignoredAttributes = new Set;
  this.action = null;
  this.visitCachedSnapshot = ({element: element}) =&gt; {
    const frame = element.querySelector(&quot;#&quot; + this.element.id);
    if (frame &amp;&amp; this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }
    delete this.previousFrameElement;
  };
  this.element = element;
  this.view = new FrameView(this, this.element);
  this.appearanceObserver = new AppearanceObserver(this, this.element);
  this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
  this.linkClickObserver = new LinkClickObserver(this, this.element);
  this.restorationIdentifier = uuid();
  this.formSubmitObserver = new FormSubmitObserver(this, this.element);
}
connect() {
  if (!this.connected) {
    this.connected = true;
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.loadSourceURL();
    }
    this.formLinkClickObserver.start();
    this.linkClickObserver.start();
    this.formSubmitObserver.start();
  }
}
disconnect() {
  if (this.connected) {
    this.connected = false;
    this.appearanceObserver.stop();
    this.formLinkClickObserver.stop();
    this.linkClickObserver.stop();
    this.formSubmitObserver.stop();
  }
}
disabledChanged() {
  if (this.loadingStyle == FrameLoadingStyle.eager) {
    this.loadSourceURL();
  }
}
sourceURLChanged() {
  if (this.isIgnoringChangesTo(&quot;src&quot;)) return;
  if (this.element.isConnected) {
    this.complete = false;
  }
  if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
    this.loadSourceURL();
  }
}
completeChanged() {
  if (this.isIgnoringChangesTo(&quot;complete&quot;)) return;
  this.loadSourceURL();
}
loadingStyleChanged() {
  if (this.loadingStyle == FrameLoadingStyle.lazy) {
    this.appearanceObserver.start();
  } else {
    this.appearanceObserver.stop();
    this.loadSourceURL();
  }
}
async loadSourceURL() {
  if (this.enabled &amp;&amp; this.isActive &amp;&amp; !this.complete &amp;&amp; this.sourceURL) {
    this.element.loaded = this.visit(expandURL(this.sourceURL));
    this.appearanceObserver.stop();
    await this.element.loaded;
    this.hasBeenLoaded = true;
  }
}
async loadResponse(fetchResponse) {
  if (fetchResponse.redirected || fetchResponse.succeeded &amp;&amp; fetchResponse.isHTML) {
    this.sourceURL = fetchResponse.response.url;
  }
  try {
    const html = await fetchResponse.responseHTML;
    if (html) {
      const {body: body} = parseHTMLDocument(html);
      const newFrameElement = await this.extractForeignFrameElement(body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise) await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        this.fetchResponseLoaded(fetchResponse);
      } else if (this.willHandleFrameMissingFromResponse(fetchResponse)) {
        console.warn(`A matching frame for #${this.element.id} was missing from the response, transforming into full-page Visit.`);
        this.visitResponse(fetchResponse.response);
      }
    }
  } catch (error) {
    console.error(error);
    this.view.invalidate();
  } finally {
    this.fetchResponseLoaded = () =&gt; {};
  }
}
elementAppearedInViewport(_element) {
  this.loadSourceURL();
}
willSubmitFormLinkToLocation(link) {
  return link.closest(&quot;turbo-frame&quot;) == this.element &amp;&amp; this.shouldInterceptNavigation(link);
}
submittedFormLinkToLocation(link, _location, form) {
  const frame = this.findFrameElement(link);
  if (frame) form.setAttribute(&quot;data-turbo-frame&quot;, frame.id);
}
willFollowLinkToLocation(element, location, event) {
  return this.shouldInterceptNavigation(element) &amp;&amp; this.frameAllowsVisitingLocation(element, location, event);
}
followedLinkToLocation(element, location) {
  this.navigateFrame(element, location.href);
}
willSubmitForm(element, submitter) {
  return element.closest(&quot;turbo-frame&quot;) == this.element &amp;&amp; this.shouldInterceptNavigation(element, submitter);
}
formSubmitted(element, submitter) {
  if (this.formSubmission) {
    this.formSubmission.stop();
  }
  this.formSubmission = new FormSubmission(this, element, submitter);
  const {fetchRequest: fetchRequest} = this.formSubmission;
  this.prepareHeadersForRequest(fetchRequest.headers, fetchRequest);
  this.formSubmission.start();
}
prepareHeadersForRequest(headers, request) {
  var _a;
  headers[&quot;Turbo-Frame&quot;] = this.id;
  if ((_a = this.currentNavigationElement) === null || _a === void 0 ? void 0 : _a.hasAttribute(&quot;data-turbo-stream&quot;)) {
    request.acceptResponseType(StreamMessage.contentType);
  }
}
requestStarted(_request) {
  markAsBusy(this.element);
}
requestPreventedHandlingResponse(_request, _response) {
  this.resolveVisitPromise();
}
async requestSucceededWithResponse(request, response) {
  await this.loadResponse(response);
  this.resolveVisitPromise();
}
async requestFailedWithResponse(request, response) {
  console.error(response);
  await this.loadResponse(response);
  this.resolveVisitPromise();
}
requestErrored(request, error) {
  console.error(error);
  this.resolveVisitPromise();
}
requestFinished(_request) {
  clearBusyState(this.element);
}
formSubmissionStarted({formElement: formElement}) {
  markAsBusy(formElement, this.findFrameElement(formElement));
}
formSubmissionSucceededWithResponse(formSubmission, response) {
  const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
  this.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
  frame.delegate.loadResponse(response);
}
formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
  this.element.delegate.loadResponse(fetchResponse);
}
formSubmissionErrored(formSubmission, error) {
  console.error(error);
}
formSubmissionFinished({formElement: formElement}) {
  clearBusyState(formElement, this.findFrameElement(formElement));
}
allowsImmediateRender({element: newFrame}, options) {
  const event = dispatch(&quot;turbo:before-frame-render&quot;, {
    target: this.element,
    detail: Object.assign({
      newFrame: newFrame
    }, options),
    cancelable: true
  });
  const {defaultPrevented: defaultPrevented, detail: {render: render}} = event;
  if (this.view.renderer &amp;&amp; render) {
    this.view.renderer.renderElement = render;
  }
  return !defaultPrevented;
}
viewRenderedSnapshot(_snapshot, _isPreview) {}
preloadOnLoadLinksForView(element) {
  session.preloadOnLoadLinksForView(element);
}
viewInvalidated() {}
willRenderFrame(currentElement, _newElement) {
  this.previousFrameElement = currentElement.cloneNode(true);
}
async visit(url) {
  var _a;
  const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams, this.element);
  (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
  this.currentFetchRequest = request;
  return new Promise((resolve =&gt; {
    this.resolveVisitPromise = () =&gt; {
      this.resolveVisitPromise = () =&gt; {};
      this.currentFetchRequest = null;
      resolve();
    };
    request.perform();
  }));
}
navigateFrame(element, url, submitter) {
  const frame = this.findFrameElement(element, submitter);
  this.proposeVisitIfNavigatedWithAction(frame, element, submitter);
  this.withCurrentNavigationElement(element, (() =&gt; {
    frame.src = url;
  }));
}
proposeVisitIfNavigatedWithAction(frame, element, submitter) {
  this.action = getVisitAction(submitter, element, frame);
  this.frame = frame;
  if (isAction(this.action)) {
    const {visitCachedSnapshot: visitCachedSnapshot} = frame.delegate;
    frame.delegate.fetchResponseLoaded = fetchResponse =&gt; {
      if (frame.src) {
        const {statusCode: statusCode, redirected: redirected} = fetchResponse;
        const responseHTML = frame.ownerDocument.documentElement.outerHTML;
        const response = {
          statusCode: statusCode,
          redirected: redirected,
          responseHTML: responseHTML
        };
        const options = {
          response: response,
          visitCachedSnapshot: visitCachedSnapshot,
          willRender: false,
          updateHistory: false,
          restorationIdentifier: this.restorationIdentifier
        };
        if (this.action) options.action = this.action;
        session.visit(frame.src, options);
      }
    };
  }
}
changeHistory() {
  if (this.action &amp;&amp; this.frame) {
    const method = getHistoryMethodForAction(this.action);
    session.history.update(method, expandURL(this.frame.src || &quot;&quot;), this.restorationIdentifier);
  }
}
willHandleFrameMissingFromResponse(fetchResponse) {
  this.element.setAttribute(&quot;complete&quot;, &quot;&quot;);
  const response = fetchResponse.response;
  const visit = async (url, options = {}) =&gt; {
    if (url instanceof Response) {
      this.visitResponse(url);
    } else {
      session.visit(url, options);
    }
  };
  const event = dispatch(&quot;turbo:frame-missing&quot;, {
    target: this.element,
    detail: {
      response: response,
      visit: visit
    },
    cancelable: true
  });
  return !event.defaultPrevented;
}
async visitResponse(response) {
  const wrapped = new FetchResponse(response);
  const responseHTML = await wrapped.responseHTML;
  const {location: location, redirected: redirected, statusCode: statusCode} = wrapped;
  return session.visit(location, {
    response: {
      redirected: redirected,
      statusCode: statusCode,
      responseHTML: responseHTML
    }
  });
}
findFrameElement(element, submitter) {
  var _a;
  const id = getAttribute(&quot;data-turbo-frame&quot;, submitter, element) || this.element.getAttribute(&quot;target&quot;);
  return (_a = getFrameElementById(id)) !== null &amp;&amp; _a !== void 0 ? _a : this.element;
}
async extractForeignFrameElement(container) {
  let element;
  const id = CSS.escape(this.id);
  try {
    element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
    if (element) {
      return element;
    }
    element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
    if (element) {
      await element.loaded;
      return await this.extractForeignFrameElement(element);
    }
  } catch (error) {
    console.error(error);
    return new FrameElement;
  }
  return null;
}
formActionIsVisitable(form, submitter) {
  const action = getAction(form, submitter);
  return locationIsVisitable(expandURL(action), this.rootLocation);
}
shouldInterceptNavigation(element, submitter) {
  const id = getAttribute(&quot;data-turbo-frame&quot;, submitter, element) || this.element.getAttribute(&quot;target&quot;);
  if (element instanceof HTMLFormElement &amp;&amp; !this.formActionIsVisitable(element, submitter)) {
    return false;
  }
  if (!this.enabled || id == &quot;_top&quot;) {
    return false;
  }
  if (id) {
    const frameElement = getFrameElementById(id);
    if (frameElement) {
      return !frameElement.disabled;
    }
  }
  if (!session.elementIsNavigatable(element)) {
    return false;
  }
  if (submitter &amp;&amp; !session.elementIsNavigatable(submitter)) {
    return false;
  }
  return true;
}
get id() {
  return this.element.id;
}
get enabled() {
  return !this.element.disabled;
}
get sourceURL() {
  if (this.element.src) {
    return this.element.src;
  }
}
set sourceURL(sourceURL) {
  this.ignoringChangesToAttribute(&quot;src&quot;, (() =&gt; {
    this.element.src = sourceURL !== null &amp;&amp; sourceURL !== void 0 ? sourceURL : null;
  }));
}
get loadingStyle() {
  return this.element.loading;
}
get isLoading() {
  return this.formSubmission !== undefined || this.resolveVisitPromise() !== undefined;
}
get complete() {
  return this.element.hasAttribute(&quot;complete&quot;);
}
set complete(value) {
  this.ignoringChangesToAttribute(&quot;complete&quot;, (() =&gt; {
    if (value) {
      this.element.setAttribute(&quot;complete&quot;, &quot;&quot;);
    } else {
      this.element.removeAttribute(&quot;complete&quot;);
    }
  }));
}
get isActive() {
  return this.element.isActive &amp;&amp; this.connected;
}
get rootLocation() {
  var _a;
  const meta = this.element.ownerDocument.querySelector(`meta[name=&quot;turbo-root&quot;]`);
  const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null &amp;&amp; _a !== void 0 ? _a : &quot;/&quot;;
  return expandURL(root);
}
frameAllowsVisitingLocation(target, {href: url}, originalEvent) {
  const event = dispatch(&quot;turbo:click&quot;, {
    target: target,
    detail: {
      url: url,
      originalEvent: originalEvent
    },
    cancelable: true
  });
  return !event.defaultPrevented;
}
isIgnoringChangesTo(attributeName) {
  return this.ignoredAttributes.has(attributeName);
}
ignoringChangesToAttribute(attributeName, callback) {
  this.ignoredAttributes.add(attributeName);
  callback();
  this.ignoredAttributes.delete(attributeName);
}
withCurrentNavigationElement(element, callback) {
  this.currentNavigationElement = element;
  callback();
  delete this.currentNavigationElement;
}</pre>

<p>}</p>

<p>function getFrameElementById(id) {</p>

<pre>if (id != null) {
  const element = document.getElementById(id);
  if (element instanceof FrameElement) {
    return element;
  }
}</pre>

<p>}</p>

<p>function activateElement(element, currentURL) {</p>

<pre>if (element) {
  const src = element.getAttribute(&quot;src&quot;);
  if (src != null &amp;&amp; currentURL != null &amp;&amp; urlsAreEqual(src, currentURL)) {
    throw new Error(`Matching &lt;turbo-frame id=&quot;${element.id}&quot;&gt; element has a source URL which references itself`);
  }
  if (element.ownerDocument !== document) {
    element = document.importNode(element, true);
  }
  if (element instanceof FrameElement) {
    element.connectedCallback();
    element.disconnectedCallback();
    return element;
  }
}</pre>

<p>}</p>

<p>class StreamElement extends HTMLElement {</p>

<pre>static async renderElement(newElement) {
  await newElement.performAction();
}
async connectedCallback() {
  try {
    await this.render();
  } catch (error) {
    console.error(error);
  } finally {
    this.disconnect();
  }
}
async render() {
  var _a;
  return (_a = this.renderPromise) !== null &amp;&amp; _a !== void 0 ? _a : this.renderPromise = (async () =&gt; {
    const event = this.beforeRenderEvent;
    if (this.dispatchEvent(event)) {
      await nextAnimationFrame();
      await event.detail.render(this);
    }
  })();
}
disconnect() {
  try {
    this.remove();
  } catch (_a) {}
}
removeDuplicateTargetChildren() {
  this.duplicateChildren.forEach((c =&gt; c.remove()));
}
get duplicateChildren() {
  var _a;
  const existingChildren = this.targetElements.flatMap((e =&gt; [ ...e.children ])).filter((c =&gt; !!c.id));
  const newChildrenIds = [ ...((_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children) || [] ].filter((c =&gt; !!c.id)).map((c =&gt; c.id));
  return existingChildren.filter((c =&gt; newChildrenIds.includes(c.id)));
}
get performAction() {
  if (this.action) {
    const actionFunction = StreamActions[this.action];
    if (actionFunction) {
      return actionFunction;
    }
    this.raise(&quot;unknown action&quot;);
  }
  this.raise(&quot;action attribute is missing&quot;);
}
get targetElements() {
  if (this.target) {
    return this.targetElementsById;
  } else if (this.targets) {
    return this.targetElementsByQuery;
  } else {
    this.raise(&quot;target or targets attribute is missing&quot;);
  }
}
get templateContent() {
  return this.templateElement.content.cloneNode(true);
}
get templateElement() {
  if (this.firstElementChild === null) {
    const template = this.ownerDocument.createElement(&quot;template&quot;);
    this.appendChild(template);
    return template;
  } else if (this.firstElementChild instanceof HTMLTemplateElement) {
    return this.firstElementChild;
  }
  this.raise(&quot;first child element must be a &lt;template&gt; element&quot;);
}
get action() {
  return this.getAttribute(&quot;action&quot;);
}
get target() {
  return this.getAttribute(&quot;target&quot;);
}
get targets() {
  return this.getAttribute(&quot;targets&quot;);
}
raise(message) {
  throw new Error(`${this.description}: ${message}`);
}
get description() {
  var _a, _b;
  return (_b = ((_a = this.outerHTML.match(/&lt;[^&gt;]+&gt;/)) !== null &amp;&amp; _a !== void 0 ? _a : [])[0]) !== null &amp;&amp; _b !== void 0 ? _b : &quot;&lt;turbo-stream&gt;&quot;;
}
get beforeRenderEvent() {
  return new CustomEvent(&quot;turbo:before-stream-render&quot;, {
    bubbles: true,
    cancelable: true,
    detail: {
      newStream: this,
      render: StreamElement.renderElement
    }
  });
}
get targetElementsById() {
  var _a;
  const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
  if (element !== null) {
    return [ element ];
  } else {
    return [];
  }
}
get targetElementsByQuery() {
  var _a;
  const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
  if (elements.length !== 0) {
    return Array.prototype.slice.call(elements);
  } else {
    return [];
  }
}</pre>

<p>}</p>

<p>class StreamSourceElement extends HTMLElement {</p>

<pre>constructor() {
  super(...arguments);
  this.streamSource = null;
}
connectedCallback() {
  this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
  connectStreamSource(this.streamSource);
}
disconnectedCallback() {
  if (this.streamSource) {
    disconnectStreamSource(this.streamSource);
  }
}
get src() {
  return this.getAttribute(&quot;src&quot;) || &quot;&quot;;
}</pre>

<p>}</p>

<p>FrameElement.delegateConstructor = FrameController;</p>

<p>if (customElements.get(“turbo-frame”) === undefined) {</p>

<pre class="ruby"><span class="ruby-identifier">customElements</span>.<span class="ruby-identifier">define</span>(<span class="ruby-string">&quot;turbo-frame&quot;</span>, <span class="ruby-constant">FrameElement</span>);
</pre>

<p>}</p>

<p>if (customElements.get(“turbo-stream”) === undefined) {</p>

<pre class="ruby"><span class="ruby-identifier">customElements</span>.<span class="ruby-identifier">define</span>(<span class="ruby-string">&quot;turbo-stream&quot;</span>, <span class="ruby-constant">StreamElement</span>);
</pre>

<p>}</p>

<p>if (customElements.get(“turbo-stream-source”) === undefined) {</p>

<pre class="ruby"><span class="ruby-identifier">customElements</span>.<span class="ruby-identifier">define</span>(<span class="ruby-string">&quot;turbo-stream-source&quot;</span>, <span class="ruby-constant">StreamSourceElement</span>);
</pre>

<p>}</p>

<p>(() =&gt; {</p>

<pre>let element = document.currentScript;
if (!element) return;
if (element.hasAttribute(&quot;data-turbo-suppress-warning&quot;)) return;
element = element.parentElement;
while (element) {
  if (element == document.body) {
    return console.warn(unindent`
      You are loading Turbo from a &lt;script&gt; element inside the &lt;body&gt; element. This is probably not what you meant to do!

      Load your application’s JavaScript bundle inside the &lt;head&gt; element instead. &lt;script&gt; elements in &lt;body&gt; are evaluated with each page change.

      For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

      ——
      Suppress this warning by adding a &quot;data-turbo-suppress-warning&quot; attribute to: %s
    `, element.outerHTML);
  }
  element = element.parentElement;
}</pre>

<p>})();</p>

<p>window.Turbo = Turbo;</p>

<p>start();</p>

<p>var turbo_es2017Esm = Object.freeze({</p>

<pre>__proto__: null,
FrameElement: FrameElement,
get FrameLoadingStyle() {
  return FrameLoadingStyle;
},
FrameRenderer: FrameRenderer,
PageRenderer: PageRenderer,
PageSnapshot: PageSnapshot,
StreamActions: StreamActions,
StreamElement: StreamElement,
StreamSourceElement: StreamSourceElement,
cache: cache,
clearCache: clearCache,
connectStreamSource: connectStreamSource,
disconnectStreamSource: disconnectStreamSource,
navigator: navigator$1,
registerAdapter: registerAdapter,
renderStreamMessage: renderStreamMessage,
session: session,
setConfirmMethod: setConfirmMethod,
setFormMode: setFormMode,
setProgressBarDelay: setProgressBarDelay,
start: start,
visit: visit</pre>

<p>});</p>

<p>let consumer;</p>

<p>async function getConsumer() {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">consumer</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">setConsumer</span>(<span class="ruby-identifier">createConsumer</span>().<span class="ruby-identifier">then</span>(<span class="ruby-identifier">setConsumer</span>));
</pre>

<p>}</p>

<p>function setConsumer(newConsumer) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">consumer</span> = <span class="ruby-identifier">newConsumer</span>;
</pre>

<p>}</p>

<p>async function createConsumer() {</p>

<pre>const {createConsumer: createConsumer} = await Promise.resolve().then((function() {
  return index;
}));
return createConsumer();</pre>

<p>}</p>

<p>async function subscribeTo(channel, mixin) {</p>

<pre>const {subscriptions: subscriptions} = await getConsumer();
return subscriptions.create(channel, mixin);</pre>

<p>}</p>

<p>var cable = Object.freeze({</p>

<pre>__proto__: null,
getConsumer: getConsumer,
setConsumer: setConsumer,
createConsumer: createConsumer,
subscribeTo: subscribeTo</pre>

<p>});</p>

<p>function walk(obj) {</p>

<pre>if (!obj || typeof obj !== &quot;object&quot;) return obj;
if (obj instanceof Date || obj instanceof RegExp) return obj;
if (Array.isArray(obj)) return obj.map(walk);
return Object.keys(obj).reduce((function(acc, key) {
  var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, (function(m, x) {
    return &quot;_&quot; + x.toLowerCase();
  }));
  acc[camel] = walk(obj[key]);
  return acc;
}), {});</pre>

<p>}</p>

<p>class TurboCableStreamSourceElement extends HTMLElement {</p>

<pre>async connectedCallback() {
  connectStreamSource(this);
  this.subscription = await subscribeTo(this.channel, {
    received: this.dispatchMessageEvent.bind(this)
  });
}
disconnectedCallback() {
  disconnectStreamSource(this);
  if (this.subscription) this.subscription.unsubscribe();
}
dispatchMessageEvent(data) {
  const event = new MessageEvent(&quot;message&quot;, {
    data: data
  });
  return this.dispatchEvent(event);
}
get channel() {
  const channel = this.getAttribute(&quot;channel&quot;);
  const signed_stream_name = this.getAttribute(&quot;signed-stream-name&quot;);
  return {
    channel: channel,
    signed_stream_name: signed_stream_name,
    ...walk({
      ...this.dataset
    })
  };
}</pre>

<p>}</p>

<p>customElements.define(“turbo-cable-stream-source”, TurboCableStreamSourceElement);</p>

<p>function encodeMethodIntoRequestBody(event) {</p>

<pre>if (event.target instanceof HTMLFormElement) {
  const {target: form, detail: {fetchOptions: fetchOptions}} = event;
  form.addEventListener(&quot;turbo:submit-start&quot;, (({detail: {formSubmission: {submitter: submitter}}}) =&gt; {
    const method = submitter &amp;&amp; submitter.formMethod || fetchOptions.body &amp;&amp; fetchOptions.body.get(&quot;_method&quot;) || form.getAttribute(&quot;method&quot;);
    if (!/get/i.test(method)) {
      if (/post/i.test(method)) {
        fetchOptions.body.delete(&quot;_method&quot;);
      } else {
        fetchOptions.body.set(&quot;_method&quot;, method);
      }
      fetchOptions.method = &quot;post&quot;;
    }
  }), {
    once: true
  });
}</pre>

<p>}</p>

<p>addEventListener(“turbo:before-fetch-request”, encodeMethodIntoRequestBody);</p>

<p>var adapters = {</p>

<pre>logger: self.console,
WebSocket: self.WebSocket</pre>

<p>};</p>

<p>var logger = {</p>

<pre>log(...messages) {
  if (this.enabled) {
    messages.push(Date.now());
    adapters.logger.log(&quot;[ActionCable]&quot;, ...messages);
  }
}</pre>

<p>};</p>

<p>const now = () =&gt; (new Date).getTime();</p>

<p>const secondsSince = time =&gt; (now() - time) / 1e3;</p>

<p>class ConnectionMonitor {</p>

<pre>constructor(connection) {
  this.visibilityDidChange = this.visibilityDidChange.bind(this);
  this.connection = connection;
  this.reconnectAttempts = 0;
}
start() {
  if (!this.isRunning()) {
    this.startedAt = now();
    delete this.stoppedAt;
    this.startPolling();
    addEventListener(&quot;visibilitychange&quot;, this.visibilityDidChange);
    logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
  }
}
stop() {
  if (this.isRunning()) {
    this.stoppedAt = now();
    this.stopPolling();
    removeEventListener(&quot;visibilitychange&quot;, this.visibilityDidChange);
    logger.log(&quot;ConnectionMonitor stopped&quot;);
  }
}
isRunning() {
  return this.startedAt &amp;&amp; !this.stoppedAt;
}
recordPing() {
  this.pingedAt = now();
}
recordConnect() {
  this.reconnectAttempts = 0;
  this.recordPing();
  delete this.disconnectedAt;
  logger.log(&quot;ConnectionMonitor recorded connect&quot;);
}
recordDisconnect() {
  this.disconnectedAt = now();
  logger.log(&quot;ConnectionMonitor recorded disconnect&quot;);
}
startPolling() {
  this.stopPolling();
  this.poll();
}
stopPolling() {
  clearTimeout(this.pollTimeout);
}
poll() {
  this.pollTimeout = setTimeout((() =&gt; {
    this.reconnectIfStale();
    this.poll();
  }), this.getPollInterval());
}
getPollInterval() {
  const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;
  const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
  const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
  const jitter = jitterMax * Math.random();
  return staleThreshold * 1e3 * backoff * (1 + jitter);
}
reconnectIfStale() {
  if (this.connectionIsStale()) {
    logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
    this.reconnectAttempts++;
    if (this.disconnectedRecently()) {
      logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
    } else {
      logger.log(&quot;ConnectionMonitor reopening&quot;);
      this.connection.reopen();
    }
  }
}
get refreshedAt() {
  return this.pingedAt ? this.pingedAt : this.startedAt;
}
connectionIsStale() {
  return secondsSince(this.refreshedAt) &gt; this.constructor.staleThreshold;
}
disconnectedRecently() {
  return this.disconnectedAt &amp;&amp; secondsSince(this.disconnectedAt) &lt; this.constructor.staleThreshold;
}
visibilityDidChange() {
  if (document.visibilityState === &quot;visible&quot;) {
    setTimeout((() =&gt; {
      if (this.connectionIsStale() || !this.connection.isOpen()) {
        logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
        this.connection.reopen();
      }
    }), 200);
  }
}</pre>

<p>}</p>

<p>ConnectionMonitor.staleThreshold = 6;</p>

<p>ConnectionMonitor.reconnectionBackoffRate = .15;</p>

<p>var INTERNAL = {</p>

<pre>message_types: {
  welcome: &quot;welcome&quot;,
  disconnect: &quot;disconnect&quot;,
  ping: &quot;ping&quot;,
  confirmation: &quot;confirm_subscription&quot;,
  rejection: &quot;reject_subscription&quot;
},
disconnect_reasons: {
  unauthorized: &quot;unauthorized&quot;,
  invalid_request: &quot;invalid_request&quot;,
  server_restart: &quot;server_restart&quot;
},
default_mount_path: &quot;/cable&quot;,
protocols: [ &quot;actioncable-v1-json&quot;, &quot;actioncable-unsupported&quot; ]</pre>

<p>};</p>

<p>const {message_types: message_types, protocols: protocols} = INTERNAL;</p>

<p>const supportedProtocols = protocols.slice(0, protocols.length - 1);</p>

<p>const indexOf = [].indexOf;</p>

<p>class Connection {</p>

<pre>constructor(consumer) {
  this.open = this.open.bind(this);
  this.consumer = consumer;
  this.subscriptions = this.consumer.subscriptions;
  this.monitor = new ConnectionMonitor(this);
  this.disconnected = true;
}
send(data) {
  if (this.isOpen()) {
    this.webSocket.send(JSON.stringify(data));
    return true;
  } else {
    return false;
  }
}
open() {
  if (this.isActive()) {
    logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
    return false;
  } else {
    logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
    if (this.webSocket) {
      this.uninstallEventHandlers();
    }
    this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);
    this.installEventHandlers();
    this.monitor.start();
    return true;
  }
}
close({allowReconnect: allowReconnect} = {
  allowReconnect: true
}) {
  if (!allowReconnect) {
    this.monitor.stop();
  }
  if (this.isActive()) {
    return this.webSocket.close();
  }
}
reopen() {
  logger.log(`Reopening WebSocket, current state is ${this.getState()}`);
  if (this.isActive()) {
    try {
      return this.close();
    } catch (error) {
      logger.log(&quot;Failed to reopen WebSocket&quot;, error);
    } finally {
      logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
      setTimeout(this.open, this.constructor.reopenDelay);
    }
  } else {
    return this.open();
  }
}
getProtocol() {
  if (this.webSocket) {
    return this.webSocket.protocol;
  }
}
isOpen() {
  return this.isState(&quot;open&quot;);
}
isActive() {
  return this.isState(&quot;open&quot;, &quot;connecting&quot;);
}
isProtocolSupported() {
  return indexOf.call(supportedProtocols, this.getProtocol()) &gt;= 0;
}
isState(...states) {
  return indexOf.call(states, this.getState()) &gt;= 0;
}
getState() {
  if (this.webSocket) {
    for (let state in adapters.WebSocket) {
      if (adapters.WebSocket[state] === this.webSocket.readyState) {
        return state.toLowerCase();
      }
    }
  }
  return null;
}
installEventHandlers() {
  for (let eventName in this.events) {
    const handler = this.events[eventName].bind(this);
    this.webSocket[`on${eventName}`] = handler;
  }
}
uninstallEventHandlers() {
  for (let eventName in this.events) {
    this.webSocket[`on${eventName}`] = function() {};
  }
}</pre>

<p>}</p>

<p>Connection.reopenDelay = 500;</p>

<p>Connection.prototype.events = {</p>

<pre>message(event) {
  if (!this.isProtocolSupported()) {
    return;
  }
  const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);
  switch (type) {
   case message_types.welcome:
    this.monitor.recordConnect();
    return this.subscriptions.reload();

   case message_types.disconnect:
    logger.log(`Disconnecting. Reason: ${reason}`);
    return this.close({
      allowReconnect: reconnect
    });

   case message_types.ping:
    return this.monitor.recordPing();

   case message_types.confirmation:
    this.subscriptions.confirmSubscription(identifier);
    return this.subscriptions.notify(identifier, &quot;connected&quot;);

   case message_types.rejection:
    return this.subscriptions.reject(identifier);

   default:
    return this.subscriptions.notify(identifier, &quot;received&quot;, message);
  }
},
open() {
  logger.log(`WebSocket onopen event, using &#39;${this.getProtocol()}&#39; subprotocol`);
  this.disconnected = false;
  if (!this.isProtocolSupported()) {
    logger.log(&quot;Protocol is unsupported. Stopping monitor and disconnecting.&quot;);
    return this.close({
      allowReconnect: false
    });
  }
},
close(event) {
  logger.log(&quot;WebSocket onclose event&quot;);
  if (this.disconnected) {
    return;
  }
  this.disconnected = true;
  this.monitor.recordDisconnect();
  return this.subscriptions.notifyAll(&quot;disconnected&quot;, {
    willAttemptReconnect: this.monitor.isRunning()
  });
},
error() {
  logger.log(&quot;WebSocket onerror event&quot;);
}</pre>

<p>};</p>

<p>const extend = function(object, properties) {</p>

<pre>if (properties != null) {
  for (let key in properties) {
    const value = properties[key];
    object[key] = value;
  }
}
return object;</pre>

<p>};</p>

<p>class Subscription {</p>

<pre class="ruby"><span class="ruby-identifier">constructor</span>(<span class="ruby-identifier">consumer</span>, <span class="ruby-identifier">params</span> = {}, <span class="ruby-identifier">mixin</span>) {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">consumer</span> = <span class="ruby-identifier">consumer</span>;
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">identifier</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">stringify</span>(<span class="ruby-identifier">params</span>);
  <span class="ruby-identifier">extend</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">mixin</span>);
}
<span class="ruby-identifier">perform</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">data</span> = {}) {
  <span class="ruby-identifier">data</span>.<span class="ruby-identifier">action</span> = <span class="ruby-identifier">action</span>;
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">data</span>);
}
<span class="ruby-identifier">send</span>(<span class="ruby-identifier">data</span>) {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">consumer</span>.<span class="ruby-identifier">send</span>({
    <span class="ruby-value">command:</span> <span class="ruby-string">&quot;message&quot;</span>,
    <span class="ruby-value">identifier:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">identifier</span>,
    <span class="ruby-value">data:</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">stringify</span>(<span class="ruby-identifier">data</span>)
  });
}
<span class="ruby-identifier">unsubscribe</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">consumer</span>.<span class="ruby-identifier">subscriptions</span>.<span class="ruby-identifier">remove</span>(<span class="ruby-identifier">this</span>);
}
</pre>

<p>}</p>

<p>class SubscriptionGuarantor {</p>

<pre>constructor(subscriptions) {
  this.subscriptions = subscriptions;
  this.pendingSubscriptions = [];
}
guarantee(subscription) {
  if (this.pendingSubscriptions.indexOf(subscription) == -1) {
    logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
    this.pendingSubscriptions.push(subscription);
  } else {
    logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
  }
  this.startGuaranteeing();
}
forget(subscription) {
  logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
  this.pendingSubscriptions = this.pendingSubscriptions.filter((s =&gt; s !== subscription));
}
startGuaranteeing() {
  this.stopGuaranteeing();
  this.retrySubscribing();
}
stopGuaranteeing() {
  clearTimeout(this.retryTimeout);
}
retrySubscribing() {
  this.retryTimeout = setTimeout((() =&gt; {
    if (this.subscriptions &amp;&amp; typeof this.subscriptions.subscribe === &quot;function&quot;) {
      this.pendingSubscriptions.map((subscription =&gt; {
        logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
        this.subscriptions.subscribe(subscription);
      }));
    }
  }), 500);
}</pre>

<p>}</p>

<p>class Subscriptions {</p>

<pre>constructor(consumer) {
  this.consumer = consumer;
  this.guarantor = new SubscriptionGuarantor(this);
  this.subscriptions = [];
}
create(channelName, mixin) {
  const channel = channelName;
  const params = typeof channel === &quot;object&quot; ? channel : {
    channel: channel
  };
  const subscription = new Subscription(this.consumer, params, mixin);
  return this.add(subscription);
}
add(subscription) {
  this.subscriptions.push(subscription);
  this.consumer.ensureActiveConnection();
  this.notify(subscription, &quot;initialized&quot;);
  this.subscribe(subscription);
  return subscription;
}
remove(subscription) {
  this.forget(subscription);
  if (!this.findAll(subscription.identifier).length) {
    this.sendCommand(subscription, &quot;unsubscribe&quot;);
  }
  return subscription;
}
reject(identifier) {
  return this.findAll(identifier).map((subscription =&gt; {
    this.forget(subscription);
    this.notify(subscription, &quot;rejected&quot;);
    return subscription;
  }));
}
forget(subscription) {
  this.guarantor.forget(subscription);
  this.subscriptions = this.subscriptions.filter((s =&gt; s !== subscription));
  return subscription;
}
findAll(identifier) {
  return this.subscriptions.filter((s =&gt; s.identifier === identifier));
}
reload() {
  return this.subscriptions.map((subscription =&gt; this.subscribe(subscription)));
}
notifyAll(callbackName, ...args) {
  return this.subscriptions.map((subscription =&gt; this.notify(subscription, callbackName, ...args)));
}
notify(subscription, callbackName, ...args) {
  let subscriptions;
  if (typeof subscription === &quot;string&quot;) {
    subscriptions = this.findAll(subscription);
  } else {
    subscriptions = [ subscription ];
  }
  return subscriptions.map((subscription =&gt; typeof subscription[callbackName] === &quot;function&quot; ? subscription[callbackName](...args) : undefined));
}
subscribe(subscription) {
  if (this.sendCommand(subscription, &quot;subscribe&quot;)) {
    this.guarantor.guarantee(subscription);
  }
}
confirmSubscription(identifier) {
  logger.log(`Subscription confirmed ${identifier}`);
  this.findAll(identifier).map((subscription =&gt; this.guarantor.forget(subscription)));
}
sendCommand(subscription, command) {
  const {identifier: identifier} = subscription;
  return this.consumer.send({
    command: command,
    identifier: identifier
  });
}</pre>

<p>}</p>

<p>class Consumer {</p>

<pre>constructor(url) {
  this._url = url;
  this.subscriptions = new Subscriptions(this);
  this.connection = new Connection(this);
}
get url() {
  return createWebSocketURL(this._url);
}
send(data) {
  return this.connection.send(data);
}
connect() {
  return this.connection.open();
}
disconnect() {
  return this.connection.close({
    allowReconnect: false
  });
}
ensureActiveConnection() {
  if (!this.connection.isActive()) {
    return this.connection.open();
  }
}</pre>

<p>}</p>

<p>function createWebSocketURL(url) {</p>

<pre>if (typeof url === &quot;function&quot;) {
  url = url();
}
if (url &amp;&amp; !/^wss?:/i.test(url)) {
  const a = document.createElement(&quot;a&quot;);
  a.href = url;
  a.href = a.href;
  a.protocol = a.protocol.replace(&quot;http&quot;, &quot;ws&quot;);
  return a.href;
} else {
  return url;
}</pre>

<p>}</p>

<p>function createConsumer$1(url = getConfig(“url”) || INTERNAL.default_mount_path) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Consumer</span>(<span class="ruby-identifier">url</span>);
</pre>

<p>}</p>

<p>function getConfig(name) {</p>

<pre>const element = document.head.querySelector(`meta[name=&#39;action-cable-${name}&#39;]`);
if (element) {
  return element.getAttribute(&quot;content&quot;);
}</pre>

<p>}</p>

<p>var index = Object.freeze({</p>

<pre>__proto__: null,
Connection: Connection,
ConnectionMonitor: ConnectionMonitor,
Consumer: Consumer,
INTERNAL: INTERNAL,
Subscription: Subscription,
Subscriptions: Subscriptions,
SubscriptionGuarantor: SubscriptionGuarantor,
adapters: adapters,
createWebSocketURL: createWebSocketURL,
logger: logger,
createConsumer: createConsumer$1,
getConfig: getConfig</pre>

<p>});</p>

<p>export { turbo_es2017Esm as Turbo, cable };</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

