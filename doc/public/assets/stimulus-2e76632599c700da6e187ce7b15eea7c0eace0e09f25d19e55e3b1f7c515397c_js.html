<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>stimulus-2e76632599c700da6e187ce7b15eea7c0eace0e09f25d19e55e3b1f7c515397c.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../Gemfile.html">Gemfile</a>
    <li><a href="../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../README_md.html">README</a>
    <li><a href="../../Rakefile.html">Rakefile</a>
    <li><a href="../../app/assets/config/manifest_js.html">manifest.js</a>
    <li><a href="../../app/assets/stylesheets/application_scss.html">application.scss</a>
    <li><a href="../../app/assets/stylesheets/custom_css.html">custom.css</a>
    <li><a href="../../app/javascript/application_js.html">application.js</a>
    <li><a href="../../app/javascript/controllers/application_js.html">application.js</a>
    <li><a href="../../app/javascript/controllers/hello_controller_js.html">hello_controller.js</a>
    <li><a href="../../app/javascript/controllers/index_js.html">index.js</a>
    <li><a href="../../bin/bundle_cmd.html">bundle.cmd</a>
    <li><a href="../../config_ru.html">config.ru</a>
    <li><a href="../../config/credentials_yml_enc.html">credentials.yml.enc</a>
    <li><a href="../../config/master_key.html">master.key</a>
    <li><a href="../../db/production_sqlite3.html">production.sqlite3</a>
    <li><a href="../../log/development_log.html">development.log</a>
    <li><a href="../../log/production_log.html">production.log</a>
    <li><a href="../../public/404_html.html">404.html</a>
    <li><a href="../../public/422_html.html">422.html</a>
    <li><a href="../../public/500_html.html">500.html</a>
    <li><a href="../../public/apple-touch-icon-precomposed_png.html">apple-touch-icon-precomposed.png</a>
    <li><a href="../../public/apple-touch-icon_png.html">apple-touch-icon.png</a>
    <li><a href="../../public/assets/actioncable-5433453f9b6619a9de91aaab2d7fc7ff183e5260c0107cbc9a1aa0c838d9a74e_js.html">actioncable-5433453f9b6619a9de91aaab2d7fc7ff183e5260c0107cbc9a1aa0c838d9a74e.js</a>
    <li><a href="../../public/assets/actioncable_esm-e01089c3ec4fe7817fa9abcad06cab6bdc387f95f0ca6aab4bf7ba7537f70690_js.html">actioncable.esm-e01089c3ec4fe7817fa9abcad06cab6bdc387f95f0ca6aab4bf7ba7537f70690.js</a>
    <li><a href="../../public/assets/actiontext-28c61f5197c204db043317a8f8826a87ab31495b741f854d307ca36122deefce_js.html">actiontext-28c61f5197c204db043317a8f8826a87ab31495b741f854d307ca36122deefce.js</a>
    <li><a href="../../public/assets/activestorage-3ab61e47dd4ee2d79db525ade1dca2ede0ea2b7371fe587e408ee37b7ade265d_js.html">activestorage-3ab61e47dd4ee2d79db525ade1dca2ede0ea2b7371fe587e408ee37b7ade265d.js</a>
    <li><a href="../../public/assets/activestorage_esm-01f58a45d77495cdfbdfcc872902a430426c4391634ec9c3da5f69fbf8418492_js.html">activestorage.esm-01f58a45d77495cdfbdfcc872902a430426c4391634ec9c3da5f69fbf8418492.js</a>
    <li><a href="../../public/assets/application-32d4b75e744a8a8e755359e6017482014dee13b0c2f0861d571e55531d39a79d_css.html">application-32d4b75e744a8a8e755359e6017482014dee13b0c2f0861d571e55531d39a79d.css</a>
    <li><a href="../../public/assets/application-3e73deab22b3cbf32eae8a405cc3f28cfe3ab81a37fecca6ddbbe46c75af5b0e_css.html">application-3e73deab22b3cbf32eae8a405cc3f28cfe3ab81a37fecca6ddbbe46c75af5b0e.css</a>
    <li><a href="../../public/assets/application-4668a63fc7682ef88af586a54008d0c129dc516b342577afb0de28e081796840_css.html">application-4668a63fc7682ef88af586a54008d0c129dc516b342577afb0de28e081796840.css</a>
    <li><a href="../../public/assets/application-7ac6076e7d9cab030797f1bfe2cf764861a60dc215f623dde8cb933ae0bf10dc_js.html">application-7ac6076e7d9cab030797f1bfe2cf764861a60dc215f623dde8cb933ae0bf10dc.js</a>
    <li><a href="../../public/assets/application-a44e181b486d978d63932a4db09338ae502d90e10c0bdd395aa839123aeea2ec_css.html">application-a44e181b486d978d63932a4db09338ae502d90e10c0bdd395aa839123aeea2ec.css</a>
    <li><a href="../../public/assets/application-ac2e01aa9a494aeeba9e1c95a30a26e3dd5b5ac439d25b67aa38832295e26c3d_css.html">application-ac2e01aa9a494aeeba9e1c95a30a26e3dd5b5ac439d25b67aa38832295e26c3d.css</a>
    <li><a href="../../public/assets/application-dc2d2d6cd177033c4b2946f0fdc563dc111e103bced6042c2b7649f314306f58_css.html">application-dc2d2d6cd177033c4b2946f0fdc563dc111e103bced6042c2b7649f314306f58.css</a>
    <li><a href="../../public/assets/bootstrap_min-20a034247d4d545a7a2d49d62ee00c40f53f825562ed9d6c9af1ad42383e67f6_js.html">bootstrap.min-20a034247d4d545a7a2d49d62ee00c40f53f825562ed9d6c9af1ad42383e67f6.js</a>
    <li><a href="../../public/assets/controllers/application-368d98631bccbf2349e0d4f8269afb3fe9625118341966de054759d96ea86c7e_js.html">application-368d98631bccbf2349e0d4f8269afb3fe9625118341966de054759d96ea86c7e.js</a>
    <li><a href="../../public/assets/controllers/hello_controller-549135e8e7c683a538c3d6d517339ba470fcfb79d62f738a0a089ba41851a554_js.html">hello_controller-549135e8e7c683a538c3d6d517339ba470fcfb79d62f738a0a089ba41851a554.js</a>
    <li><a href="../../public/assets/controllers/index-2db729dddcc5b979110e98de4b6720f83f91a123172e87281d5a58410fc43806_js.html">index-2db729dddcc5b979110e98de4b6720f83f91a123172e87281d5a58410fc43806.js</a>
    <li><a href="../../public/assets/custom-77945ec94022f825cfe7d6166e97092d87ca4f55627c8062b56cfb9f1a35f205_css.html">custom-77945ec94022f825cfe7d6166e97092d87ca4f55627c8062b56cfb9f1a35f205.css</a>
    <li><a href="../../public/assets/custom-7eba9728e51d5c26d8d1cf50340b4b3ad9251d8a5f0142ef57211377bd50fcfc_css.html">custom-7eba9728e51d5c26d8d1cf50340b4b3ad9251d8a5f0142ef57211377bd50fcfc.css</a>
    <li><a href="../../public/assets/custom-de99a0f588d04e64f8aa62da913f7225b090eb13fbfe74a7315f1715cdefec1d_css.html">custom-de99a0f588d04e64f8aa62da913f7225b090eb13fbfe74a7315f1715cdefec1d.css</a>
    <li><a href="../../public/assets/custom-e30bda1bcb7eaa86b4f7970e250dadbfd4aa17f32943e7e25ef353bd822fd884_css.html">custom-e30bda1bcb7eaa86b4f7970e250dadbfd4aa17f32943e7e25ef353bd822fd884.css</a>
    <li><a href="../../public/assets/es-module-shims-16719834c9bbcdd75f1f99da713bd0c89de488be94d4c5df594511f39cffe7c1_js.html">es-module-shims-16719834c9bbcdd75f1f99da713bd0c89de488be94d4c5df594511f39cffe7c1.js</a>
    <li><a href="../../public/assets/es-module-shims_js-32db422c5db541b7129a2ce936aed905edc2cd481748f8d67ffe84e28313158a_map.html">es-module-shims.js-32db422c5db541b7129a2ce936aed905edc2cd481748f8d67ffe84e28313158a.map</a>
    <li><a href="../../public/assets/es-module-shims_min-d89e73202ec09dede55fb74115af9c5f9f2bb965433de1c2446e1faa6dac2470_js.html">es-module-shims.min-d89e73202ec09dede55fb74115af9c5f9f2bb965433de1c2446e1faa6dac2470.js</a>
    <li><a href="../../public/assets/manifest-b84bfa46a33d7f0dc4d2e7b8889486c9a957a5e40713d58f54be71b66954a1ff_js.html">manifest-b84bfa46a33d7f0dc4d2e7b8889486c9a957a5e40713d58f54be71b66954a1ff.js</a>
    <li><a href="../../public/assets/popper-15792033e209365e7b75c100dae2b69cba31b26b18b289383d22eb67639aad75_js.html">popper-15792033e209365e7b75c100dae2b69cba31b26b18b289383d22eb67639aad75.js</a>
    <li><a href="../../public/assets/stimulus-2e76632599c700da6e187ce7b15eea7c0eace0e09f25d19e55e3b1f7c515397c_js.html">stimulus-2e76632599c700da6e187ce7b15eea7c0eace0e09f25d19e55e3b1f7c515397c.js</a>
    <li><a href="../../public/assets/stimulus-autoloader-c584942b568ba74879da31c7c3d51366737bacaf6fbae659383c0a5653685693_js.html">stimulus-autoloader-c584942b568ba74879da31c7c3d51366737bacaf6fbae659383c0a5653685693.js</a>
    <li><a href="../../public/assets/stimulus-importmap-autoloader-db2076c783bf2dbee1226e2add52fef290b5d31b5bcd1edd999ac8a6dd31c44a_js.html">stimulus-importmap-autoloader-db2076c783bf2dbee1226e2add52fef290b5d31b5bcd1edd999ac8a6dd31c44a.js</a>
    <li><a href="../../public/assets/stimulus-loading-1fc59770fb1654500044afd3f5f6d7d00800e5be36746d55b94a2963a7a228aa_js.html">stimulus-loading-1fc59770fb1654500044afd3f5f6d7d00800e5be36746d55b94a2963a7a228aa.js</a>
    <li><a href="../../public/assets/stimulus_min-b8a9738499c7a8362910cd545375417370d72a9776fb4e766df7671484e2beb7_js.html">stimulus.min-b8a9738499c7a8362910cd545375417370d72a9776fb4e766df7671484e2beb7.js</a>
    <li><a href="../../public/assets/stimulus_min_js-8d1a076cbda7e5ed0992e208db54c62a8de8b1f9694828e1a601fbccd9291649_map.html">stimulus.min.js-8d1a076cbda7e5ed0992e208db54c62a8de8b1f9694828e1a601fbccd9291649.map</a>
    <li><a href="../../public/assets/trix-1563ff9c10f74e143b3ded40a8458497eaf2f87a648a5cbbfebdb7dec3447a5e_js.html">trix-1563ff9c10f74e143b3ded40a8458497eaf2f87a648a5cbbfebdb7dec3447a5e.js</a>
    <li><a href="../../public/assets/trix-fe178d6f8c056d8e63aecb6557bc65676897f43e4aee3e68584437841a99fc23_css.html">trix-fe178d6f8c056d8e63aecb6557bc65676897f43e4aee3e68584437841a99fc23.css</a>
    <li><a href="../../public/assets/turbo-118a59d5569d8a8b343ee3cd7f2c39b6b5fa5f236368b332e2db7bdad59d1ca9_js.html">turbo-118a59d5569d8a8b343ee3cd7f2c39b6b5fa5f236368b332e2db7bdad59d1ca9.js</a>
    <li><a href="../../public/assets/turbo_min-3b666ce240bde65e66d795553a062443a3b139e38646fe31740d354a41653fcc_js.html">turbo.min-3b666ce240bde65e66d795553a062443a3b139e38646fe31740d354a41653fcc.js</a>
    <li><a href="../../public/assets/turbo_min_js-c3141c67d707e81f67affd6a77f1657e298d5cb8aac6628e892669905b33786e_map.html">turbo.min.js-c3141c67d707e81f67affd6a77f1657e298d5cb8aac6628e892669905b33786e.map</a>
    <li><a href="../../public/favicon_ico.html">favicon.ico</a>
    <li><a href="../../public/robots_txt.html">robots</a>
    <li><a href="../../tmp/development_secret_txt.html">development_secret</a>
    <li><a href="../../tmp/pids/server_pid.html">server.pid</a>
    <li><a href="../../tmp/restart_txt.html">restart</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page public/assets/stimulus-2e76632599c700da6e187ce7b15eea7c0eace0e09f25d19e55e3b1f7c515397c.js">

<p>/* Stimulus 3.1.0 Copyright © 2022 Basecamp, LLC</p>

<pre>*/</pre>

<p>class EventListener {</p>

<pre>constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = new Set();
}
connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
}
disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
}
bindingConnected(binding) {
    this.unorderedBindings.add(binding);
}
bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
}
handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
            break;
        }
        else {
            binding.handleEvent(extendedEvent);
        }
    }
}
get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) =&gt; {
        const leftIndex = left.index, rightIndex = right.index;
        return leftIndex &lt; rightIndex ? -1 : leftIndex &gt; rightIndex ? 1 : 0;
    });
}</pre>

<p>} function extendEvent(event) {</p>

<pre>if (&quot;immediatePropagationStopped&quot; in event) {
    return event;
}
else {
    const { stopImmediatePropagation } = event;
    return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
            this.immediatePropagationStopped = true;
            stopImmediatePropagation.call(this);
        }
    });
}</pre>

<p>}</p>

<p>class Dispatcher {</p>

<pre>constructor(application) {
    this.application = application;
    this.eventListenerMaps = new Map;
    this.started = false;
}
start() {
    if (!this.started) {
        this.started = true;
        this.eventListeners.forEach(eventListener =&gt; eventListener.connect());
    }
}
stop() {
    if (this.started) {
        this.started = false;
        this.eventListeners.forEach(eventListener =&gt; eventListener.disconnect());
    }
}
get eventListeners() {
    return Array.from(this.eventListenerMaps.values())
        .reduce((listeners, map) =&gt; listeners.concat(Array.from(map.values())), []);
}
bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
}
bindingDisconnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
}
handleError(error, message, detail = {}) {
    this.application.handleError(error, `Error ${message}`, detail);
}
fetchEventListenerForBinding(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
}
fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
}
createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
        eventListener.connect();
    }
    return eventListener;
}
fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
        eventListenerMap = new Map;
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
}
cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach(key =&gt; {
        parts.push(`${eventOptions[key] ? &quot;&quot; : &quot;!&quot;}${key}`);
    });
    return parts.join(&quot;:&quot;);
}</pre>

<p>}</p>

<p>const descriptorPattern = /^((.+?)(@(<a href="^:">window|document))?->)?(.+?)(#(</a>+?))(:(.+))?$/; function parseActionDescriptorString(descriptorString) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">source</span> = <span class="ruby-identifier">descriptorString</span>.<span class="ruby-identifier">trim</span>();
<span class="ruby-identifier">const</span> <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">descriptorPattern</span>) <span class="ruby-operator">||</span> [];
<span class="ruby-keyword">return</span> {
    <span class="ruby-value">eventTarget:</span> <span class="ruby-identifier">parseEventTarget</span>(<span class="ruby-identifier">matches</span>[<span class="ruby-value">4</span>]),
    <span class="ruby-value">eventName:</span> <span class="ruby-identifier">matches</span>[<span class="ruby-value">2</span>],
    <span class="ruby-value">eventOptions:</span> <span class="ruby-identifier">matches</span>[<span class="ruby-value">9</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">parseEventOptions</span>(<span class="ruby-identifier">matches</span>[<span class="ruby-value">9</span>]) <span class="ruby-operator">:</span> {},
    <span class="ruby-value">identifier:</span> <span class="ruby-identifier">matches</span>[<span class="ruby-value">5</span>],
    <span class="ruby-value">methodName:</span> <span class="ruby-identifier">matches</span>[<span class="ruby-value">7</span>]
};
</pre>

<p>} function parseEventTarget(eventTargetName) {</p>

<pre>if (eventTargetName == &quot;window&quot;) {
    return window;
}
else if (eventTargetName == &quot;document&quot;) {
    return document;
}</pre>

<p>} function parseEventOptions(eventOptions) {</p>

<pre>return eventOptions.split(&quot;:&quot;).reduce((options, token) =&gt; Object.assign(options, { [token.replace(/^!/, &quot;&quot;)]: !/^!/.test(token) }), {});</pre>

<p>} function stringifyEventTarget(eventTarget) {</p>

<pre>if (eventTarget == window) {
    return &quot;window&quot;;
}
else if (eventTarget == document) {
    return &quot;document&quot;;
}</pre>

<p>}</p>

<p>function camelize(value) {</p>

<pre>return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) =&gt; char.toUpperCase());</pre>

<p>} function capitalize(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">charAt</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">toUpperCase</span>() <span class="ruby-operator">+</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span>);
</pre>

<p>} function dasherize(value) {</p>

<pre>return value.replace(/([A-Z])/g, (_, char) =&gt; `-${char.toLowerCase()}`);</pre>

<p>} function tokenize(value) {</p>

<pre>return value.match(/[^\s]+/g) || [];</pre>

<p>}</p>

<p>class Action {</p>

<pre>constructor(element, index, descriptor) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(&quot;missing event name&quot;);
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error(&quot;missing identifier&quot;);
    this.methodName = descriptor.methodName || error(&quot;missing method name&quot;);
}
static forToken(token) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content));
}
toString() {
    const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : &quot;&quot;;
    return `${this.eventName}${eventNameSuffix}-&gt;${this.identifier}#${this.methodName}`;
}
get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
    for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match &amp;&amp; match[1];
        if (key) {
            params[camelize(key)] = typecast(value);
        }
    }
    return params;
}
get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
}</pre>

<p>} const defaultEventNames = {</p>

<pre>&quot;a&quot;: e =&gt; &quot;click&quot;,
&quot;button&quot;: e =&gt; &quot;click&quot;,
&quot;form&quot;: e =&gt; &quot;submit&quot;,
&quot;details&quot;: e =&gt; &quot;toggle&quot;,
&quot;input&quot;: e =&gt; e.getAttribute(&quot;type&quot;) == &quot;submit&quot; ? &quot;click&quot; : &quot;input&quot;,
&quot;select&quot;: e =&gt; &quot;change&quot;,
&quot;textarea&quot;: e =&gt; &quot;input&quot;</pre>

<p>}; function getDefaultEventNameForElement(element) {</p>

<pre>const tagName = element.tagName.toLowerCase();
if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
}</pre>

<p>} function error(message) {</p>

<pre class="ruby"><span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>(<span class="ruby-identifier">message</span>);
</pre>

<p>} function typecast(value) {</p>

<pre class="ruby"><span class="ruby-identifier">try</span> {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">value</span>);
}
<span class="ruby-identifier">catch</span> (<span class="ruby-identifier">o_O</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>;
}
</pre>

<p>}</p>

<p>class Binding {</p>

<pre>constructor(context, action) {
    this.context = context;
    this.action = action;
}
get index() {
    return this.action.index;
}
get eventTarget() {
    return this.action.eventTarget;
}
get eventOptions() {
    return this.action.eventOptions;
}
get identifier() {
    return this.context.identifier;
}
handleEvent(event) {
    if (this.willBeInvokedByEvent(event) &amp;&amp; this.shouldBeInvokedPerSelf(event)) {
        this.processStopPropagation(event);
        this.processPreventDefault(event);
        this.invokeWithEvent(event);
    }
}
get eventName() {
    return this.action.eventName;
}
get method() {
    const method = this.controller[this.methodName];
    if (typeof method == &quot;function&quot;) {
        return method;
    }
    throw new Error(`Action &quot;${this.action}&quot; references undefined method &quot;${this.methodName}&quot;`);
}
processStopPropagation(event) {
    if (this.eventOptions.stop) {
        event.stopPropagation();
    }
}
processPreventDefault(event) {
    if (this.eventOptions.prevent) {
        event.preventDefault();
    }
}
invokeWithEvent(event) {
    const { target, currentTarget } = event;
    try {
        const { params } = this.action;
        const actionEvent = Object.assign(event, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
    }
    catch (error) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error, `invoking action &quot;${this.action}&quot;`, detail);
    }
}
shouldBeInvokedPerSelf(event) {
    if (this.action.eventOptions.self === true) {
        return this.action.element === event.target;
    }
    else {
        return true;
    }
}
willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (this.element === eventTarget) {
        return true;
    }
    else if (eventTarget instanceof Element &amp;&amp; this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
    }
    else {
        return this.scope.containsElement(this.action.element);
    }
}
get controller() {
    return this.context.controller;
}
get methodName() {
    return this.action.methodName;
}
get element() {
    return this.scope.element;
}
get scope() {
    return this.context.scope;
}</pre>

<p>}</p>

<p>class ElementObserver {</p>

<pre>constructor(element, delegate) {
    this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = new Set;
    this.mutationObserver = new MutationObserver((mutations) =&gt; this.processMutations(mutations));
}
start() {
    if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
    }
}
pause(callback) {
    if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
    }
    callback();
    if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
    }
}
stop() {
    if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
    }
}
refresh() {
    if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
            if (!matches.has(element)) {
                this.removeElement(element);
            }
        }
        for (const element of Array.from(matches)) {
            this.addElement(element);
        }
    }
}
processMutations(mutations) {
    if (this.started) {
        for (const mutation of mutations) {
            this.processMutation(mutation);
        }
    }
}
processMutation(mutation) {
    if (mutation.type == &quot;attributes&quot;) {
        this.processAttributeChange(mutation.target, mutation.attributeName);
    }
    else if (mutation.type == &quot;childList&quot;) {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
    }
}
processAttributeChange(node, attributeName) {
    const element = node;
    if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged &amp;&amp; this.matchElement(element)) {
            this.delegate.elementAttributeChanged(element, attributeName);
        }
        else {
            this.removeElement(element);
        }
    }
    else if (this.matchElement(element)) {
        this.addElement(element);
    }
}
processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
            this.processTree(element, this.removeElement);
        }
    }
}
processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element &amp;&amp; this.elementIsActive(element)) {
            this.processTree(element, this.addElement);
        }
    }
}
matchElement(element) {
    return this.delegate.matchElement(element);
}
matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
}
processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
    }
}
elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
    }
}
elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
        return false;
    }
    else {
        return this.element.contains(element);
    }
}
addElement(element) {
    if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
            this.elements.add(element);
            if (this.delegate.elementMatched) {
                this.delegate.elementMatched(element);
            }
        }
    }
}
removeElement(element) {
    if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
            this.delegate.elementUnmatched(element);
        }
    }
}</pre>

<p>}</p>

<p>class AttributeObserver {</p>

<pre>constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
}
get element() {
    return this.elementObserver.element;
}
get selector() {
    return `[${this.attributeName}]`;
}
start() {
    this.elementObserver.start();
}
pause(callback) {
    this.elementObserver.pause(callback);
}
stop() {
    this.elementObserver.stop();
}
refresh() {
    this.elementObserver.refresh();
}
get started() {
    return this.elementObserver.started;
}
matchElement(element) {
    return element.hasAttribute(this.attributeName);
}
matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
}
elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
}
elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
}
elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged &amp;&amp; this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
    }
}</pre>

<p>}</p>

<p>class StringMapObserver {</p>

<pre>constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = new Map;
    this.mutationObserver = new MutationObserver(mutations =&gt; this.processMutations(mutations));
}
start() {
    if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
    }
}
stop() {
    if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
    }
}
refresh() {
    if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
            this.refreshAttribute(attributeName, null);
        }
    }
}
processMutations(mutations) {
    if (this.started) {
        for (const mutation of mutations) {
            this.processMutation(mutation);
        }
    }
}
processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
    }
}
refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
        if (!this.stringMap.has(attributeName)) {
            this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
            this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
            const oldValue = this.stringMap.get(attributeName);
            this.stringMap.delete(attributeName);
            if (oldValue)
                this.stringMapKeyRemoved(key, attributeName, oldValue);
        }
        else {
            this.stringMap.set(attributeName, value);
        }
    }
}
stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
    }
}
stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
    }
}
stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
}
get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
}
get currentAttributeNames() {
    return Array.from(this.element.attributes).map(attribute =&gt; attribute.name);
}
get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
}</pre>

<p>}</p>

<p>function add(map, key, value) {</p>

<pre class="ruby"><span class="ruby-identifier">fetch</span>(<span class="ruby-identifier">map</span>, <span class="ruby-identifier">key</span>).<span class="ruby-identifier">add</span>(<span class="ruby-identifier">value</span>);
</pre>

<p>} function del(map, key, value) {</p>

<pre class="ruby"><span class="ruby-identifier">fetch</span>(<span class="ruby-identifier">map</span>, <span class="ruby-identifier">key</span>).<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">value</span>);
<span class="ruby-identifier">prune</span>(<span class="ruby-identifier">map</span>, <span class="ruby-identifier">key</span>);
</pre>

<p>} function fetch(map, key) {</p>

<pre>let values = map.get(key);
if (!values) {
    values = new Set();
    map.set(key, values);
}
return values;</pre>

<p>} function prune(map, key) {</p>

<pre>const values = map.get(key);
if (values != null &amp;&amp; values.size == 0) {
    map.delete(key);
}</pre>

<p>}</p>

<p>class Multimap {</p>

<pre>constructor() {
    this.valuesByKey = new Map();
}
get keys() {
    return Array.from(this.valuesByKey.keys());
}
get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) =&gt; values.concat(Array.from(set)), []);
}
get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) =&gt; size + set.size, 0);
}
add(key, value) {
    add(this.valuesByKey, key, value);
}
delete(key, value) {
    del(this.valuesByKey, key, value);
}
has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null &amp;&amp; values.has(value);
}
hasKey(key) {
    return this.valuesByKey.has(key);
}
hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some(set =&gt; set.has(value));
}
getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
}
getKeysForValue(value) {
    return Array.from(this.valuesByKey)
        .filter(([key, values]) =&gt; values.has(value))
        .map(([key, values]) =&gt; key);
}</pre>

<p>}</p>

<p>class IndexedMultimap extends Multimap {</p>

<pre class="ruby"><span class="ruby-identifier">constructor</span>() {
    <span class="ruby-keyword">super</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">keysByValue</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Map</span>;
}
<span class="ruby-identifier">get</span> <span class="ruby-identifier">values</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">Array</span>.<span class="ruby-identifier">from</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">keysByValue</span>.<span class="ruby-identifier">keys</span>());
}
<span class="ruby-identifier">add</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>) {
    <span class="ruby-keyword">super</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>);
    <span class="ruby-identifier">add</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">keysByValue</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">key</span>);
}
<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>) {
    <span class="ruby-keyword">super</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>);
    <span class="ruby-identifier">del</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">keysByValue</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">key</span>);
}
<span class="ruby-identifier">hasValue</span>(<span class="ruby-identifier">value</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">keysByValue</span>.<span class="ruby-identifier">has</span>(<span class="ruby-identifier">value</span>);
}
<span class="ruby-identifier">getKeysForValue</span>(<span class="ruby-identifier">value</span>) {
    <span class="ruby-identifier">const</span> <span class="ruby-identifier">set</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">keysByValue</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">value</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">set</span> <span class="ruby-operator">?</span> <span class="ruby-constant">Array</span>.<span class="ruby-identifier">from</span>(<span class="ruby-identifier">set</span>) <span class="ruby-operator">:</span> [];
}
</pre>

<p>}</p>

<p>class TokenListObserver {</p>

<pre>constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap;
}
get started() {
    return this.attributeObserver.started;
}
start() {
    this.attributeObserver.start();
}
pause(callback) {
    this.attributeObserver.pause(callback);
}
stop() {
    this.attributeObserver.stop();
}
refresh() {
    this.attributeObserver.refresh();
}
get element() {
    return this.attributeObserver.element;
}
get attributeName() {
    return this.attributeObserver.attributeName;
}
elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
}
elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
}
elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
}
tokensMatched(tokens) {
    tokens.forEach(token =&gt; this.tokenMatched(token));
}
tokensUnmatched(tokens) {
    tokens.forEach(token =&gt; this.tokenUnmatched(token));
}
tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
}
tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
}
refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens)
        .findIndex(([previousToken, currentToken]) =&gt; !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
        return [[], []];
    }
    else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
}
readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || &quot;&quot;;
    return parseTokenString(tokenString, element, attributeName);
}</pre>

<p>} function parseTokenString(tokenString, element, attributeName) {</p>

<pre>return tokenString.trim().split(/\s+/).filter(content =&gt; content.length)
    .map((content, index) =&gt; ({ element, attributeName, content, index }));</pre>

<p>} function zip(left, right) {</p>

<pre>const length = Math.max(left.length, right.length);
return Array.from({ length }, (_, index) =&gt; [left[index], right[index]]);</pre>

<p>} function tokensAreEqual(left, right) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">right</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">left</span>.<span class="ruby-identifier">index</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">right</span>.<span class="ruby-identifier">index</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">left</span>.<span class="ruby-identifier">content</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">right</span>.<span class="ruby-identifier">content</span>;
</pre>

<p>}</p>

<p>class ValueListObserver {</p>

<pre>constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = new WeakMap;
    this.valuesByTokenByElement = new WeakMap;
}
get started() {
    return this.tokenListObserver.started;
}
start() {
    this.tokenListObserver.start();
}
stop() {
    this.tokenListObserver.stop();
}
refresh() {
    this.tokenListObserver.refresh();
}
get element() {
    return this.tokenListObserver.element;
}
get attributeName() {
    return this.tokenListObserver.attributeName;
}
tokenMatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
    }
}
tokenUnmatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
    }
}
fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
}
fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
        valuesByToken = new Map;
        this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
}
parseToken(token) {
    try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
    }
    catch (error) {
        return { error };
    }
}</pre>

<p>}</p>

<p>class BindingObserver {</p>

<pre>constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = new Map;
}
start() {
    if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
    }
}
stop() {
    if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
    }
}
get element() {
    return this.context.element;
}
get identifier() {
    return this.context.identifier;
}
get actionAttribute() {
    return this.schema.actionAttribute;
}
get schema() {
    return this.context.schema;
}
get bindings() {
    return Array.from(this.bindingsByAction.values());
}
connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
}
disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
    }
}
disconnectAllActions() {
    this.bindings.forEach(binding =&gt; this.delegate.bindingDisconnected(binding));
    this.bindingsByAction.clear();
}
parseValueForToken(token) {
    const action = Action.forToken(token);
    if (action.identifier == this.identifier) {
        return action;
    }
}
elementMatchedValue(element, action) {
    this.connectAction(action);
}
elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
}</pre>

<p>}</p>

<p>class ValueObserver {</p>

<pre>constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
}
start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
}
stop() {
    this.stringMapObserver.stop();
}
get element() {
    return this.context.element;
}
get controller() {
    return this.context.controller;
}
getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
    }
}
stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
}
stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null)
        return;
    if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
}
stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    }
    else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
}
invokeChangedCallbacksForDefaultValues() {
    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != undefined &amp;&amp; !this.controller.data.has(key)) {
            this.invokeChangedCallback(name, writer(defaultValue), undefined);
        }
    }
}
invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == &quot;function&quot;) {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
            const value = descriptor.reader(rawValue);
            let oldValue = rawOldValue;
            if (rawOldValue) {
                oldValue = descriptor.reader(rawOldValue);
            }
            changedMethod.call(this.receiver, value, oldValue);
        }
        catch (error) {
            if (!(error instanceof TypeError))
                throw error;
            throw new TypeError(`Stimulus Value &quot;${this.context.identifier}.${descriptor.name}&quot; - ${error.message}`);
        }
    }
}
get valueDescriptors() {
    const { valueDescriptorMap } = this;
    return Object.keys(valueDescriptorMap).map(key =&gt; valueDescriptorMap[key]);
}
get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach(key =&gt; {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
}
hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
}</pre>

<p>}</p>

<p>class TargetObserver {</p>

<pre>constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap;
}
start() {
    if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
    }
}
stop() {
    if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
    }
}
tokenMatched({ element, content: name }) {
    if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
    }
}
tokenUnmatched({ element, content: name }) {
    this.disconnectTarget(element, name);
}
connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() =&gt; this.delegate.targetConnected(element, name));
    }
}
disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() =&gt; this.delegate.targetDisconnected(element, name));
    }
}
disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
            this.disconnectTarget(element, name);
        }
    }
}
get attributeName() {
    return `data-${this.context.identifier}-target`;
}
get element() {
    return this.context.element;
}
get scope() {
    return this.context.scope;
}</pre>

<p>}</p>

<p>class Context {</p>

<pre>constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) =&gt; {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    try {
        this.controller.initialize();
        this.logDebugActivity(&quot;initialize&quot;);
    }
    catch (error) {
        this.handleError(error, &quot;initializing controller&quot;);
    }
}
connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    try {
        this.controller.connect();
        this.logDebugActivity(&quot;connect&quot;);
    }
    catch (error) {
        this.handleError(error, &quot;connecting controller&quot;);
    }
}
disconnect() {
    try {
        this.controller.disconnect();
        this.logDebugActivity(&quot;disconnect&quot;);
    }
    catch (error) {
        this.handleError(error, &quot;disconnecting controller&quot;);
    }
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
}
get application() {
    return this.module.application;
}
get identifier() {
    return this.module.identifier;
}
get schema() {
    return this.application.schema;
}
get dispatcher() {
    return this.application.dispatcher;
}
get element() {
    return this.scope.element;
}
get parentElement() {
    return this.element.parentElement;
}
handleError(error, message, detail = {}) {
    const { identifier, controller, element } = this;
    detail = Object.assign({ identifier, controller, element }, detail);
    this.application.handleError(error, `Error ${message}`, detail);
}
targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
}
targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
}
invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == &quot;function&quot;) {
        controller[methodName](...args);
    }
}</pre>

<p>}</p>

<p>function readInheritableStaticArrayValues(constructor, propertyName) {</p>

<pre>const ancestors = getAncestorsForConstructor(constructor);
return Array.from(ancestors.reduce((values, constructor) =&gt; {
    getOwnStaticArrayValues(constructor, propertyName).forEach(name =&gt; values.add(name));
    return values;
}, new Set));</pre>

<p>} function readInheritableStaticObjectPairs(constructor, propertyName) {</p>

<pre>const ancestors = getAncestorsForConstructor(constructor);
return ancestors.reduce((pairs, constructor) =&gt; {
    pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
    return pairs;
}, []);</pre>

<p>} function getAncestorsForConstructor(constructor) {</p>

<pre>const ancestors = [];
while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
}
return ancestors.reverse();</pre>

<p>} function getOwnStaticArrayValues(constructor, propertyName) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">definition</span> = <span class="ruby-identifier">constructor</span>[<span class="ruby-identifier">propertyName</span>];
<span class="ruby-keyword">return</span> <span class="ruby-constant">Array</span>.<span class="ruby-identifier">isArray</span>(<span class="ruby-identifier">definition</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">definition</span> <span class="ruby-operator">:</span> [];
</pre>

<p>} function getOwnStaticObjectPairs(constructor, propertyName) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">definition</span> = <span class="ruby-identifier">constructor</span>[<span class="ruby-identifier">propertyName</span>];
<span class="ruby-keyword">return</span> <span class="ruby-identifier">definition</span> <span class="ruby-operator">?</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">keys</span>(<span class="ruby-identifier">definition</span>).<span class="ruby-identifier">map</span>(<span class="ruby-identifier">key</span> <span class="ruby-operator">=&gt;</span> [<span class="ruby-identifier">key</span>, <span class="ruby-identifier">definition</span>[<span class="ruby-identifier">key</span>]]) <span class="ruby-operator">:</span> [];
</pre>

<p>}</p>

<p>function bless(constructor) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">shadow</span>(<span class="ruby-identifier">constructor</span>, <span class="ruby-identifier">getBlessedProperties</span>(<span class="ruby-identifier">constructor</span>));
</pre>

<p>} function shadow(constructor, properties) {</p>

<pre class="ruby"><span class="ruby-identifier">const</span> <span class="ruby-identifier">shadowConstructor</span> = <span class="ruby-identifier">extend</span>(<span class="ruby-identifier">constructor</span>);
<span class="ruby-identifier">const</span> <span class="ruby-identifier">shadowProperties</span> = <span class="ruby-identifier">getShadowProperties</span>(<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-identifier">properties</span>);
<span class="ruby-constant">Object</span>.<span class="ruby-identifier">defineProperties</span>(<span class="ruby-identifier">shadowConstructor</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-identifier">shadowProperties</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">shadowConstructor</span>;
</pre>

<p>} function getBlessedProperties(constructor) {</p>

<pre>const blessings = readInheritableStaticArrayValues(constructor, &quot;blessings&quot;);
return blessings.reduce((blessedProperties, blessing) =&gt; {
    const properties = blessing(constructor);
    for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
}, {});</pre>

<p>} function getShadowProperties(prototype, properties) {</p>

<pre>return getOwnKeys(properties).reduce((shadowProperties, key) =&gt; {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
    }
    return shadowProperties;
}, {});</pre>

<p>} function getShadowedDescriptor(prototype, properties, key) {</p>

<pre>const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
const shadowedByValue = shadowingDescriptor &amp;&amp; &quot;value&quot; in shadowingDescriptor;
if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
}</pre>

<p>} const getOwnKeys = (() =&gt; {</p>

<pre>if (typeof Object.getOwnPropertySymbols == &quot;function&quot;) {
    return (object) =&gt; [
        ...Object.getOwnPropertyNames(object),
        ...Object.getOwnPropertySymbols(object)
    ];
}
else {
    return Object.getOwnPropertyNames;
}</pre>

<p>})(); const extend = (() =&gt; {</p>

<pre>function extendWithReflect(constructor) {
    function extended() {
        return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
}
function testReflectExtension() {
    const a = function () { this.a.call(this); };
    const b = extendWithReflect(a);
    b.prototype.a = function () { };
    return new b;
}
try {
    testReflectExtension();
    return extendWithReflect;
}
catch (error) {
    return (constructor) =&gt; class extended extends constructor {
    };
}</pre>

<p>})();</p>

<p>function blessDefinition(definition) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> {
    <span class="ruby-value">identifier:</span> <span class="ruby-identifier">definition</span>.<span class="ruby-identifier">identifier</span>,
    <span class="ruby-value">controllerConstructor:</span> <span class="ruby-identifier">bless</span>(<span class="ruby-identifier">definition</span>.<span class="ruby-identifier">controllerConstructor</span>)
};
</pre>

<p>}</p>

<p>class Module {</p>

<pre>constructor(application, definition) {
    this.application = application;
    this.definition = blessDefinition(definition);
    this.contextsByScope = new WeakMap;
    this.connectedContexts = new Set;
}
get identifier() {
    return this.definition.identifier;
}
get controllerConstructor() {
    return this.definition.controllerConstructor;
}
get contexts() {
    return Array.from(this.connectedContexts);
}
connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
}
disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
    }
}
fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
    }
    return context;
}</pre>

<p>}</p>

<p>class ClassMap {</p>

<pre class="ruby"><span class="ruby-identifier">constructor</span>(<span class="ruby-identifier">scope</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scope</span> = <span class="ruby-identifier">scope</span>;
}
<span class="ruby-identifier">has</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">data</span>.<span class="ruby-identifier">has</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">getDataKey</span>(<span class="ruby-identifier">name</span>));
}
<span class="ruby-identifier">get</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getAll</span>(<span class="ruby-identifier">name</span>)[<span class="ruby-value">0</span>];
}
<span class="ruby-identifier">getAll</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-identifier">const</span> <span class="ruby-identifier">tokenString</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">data</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">getDataKey</span>(<span class="ruby-identifier">name</span>)) <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">tokenize</span>(<span class="ruby-identifier">tokenString</span>);
}
<span class="ruby-identifier">getAttributeName</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">data</span>.<span class="ruby-identifier">getAttributeNameForKey</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">getDataKey</span>(<span class="ruby-identifier">name</span>));
}
<span class="ruby-identifier">getDataKey</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-string">`${name}-class`</span>;
}
<span class="ruby-identifier">get</span> <span class="ruby-identifier">data</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">data</span>;
}
</pre>

<p>}</p>

<p>class DataMap {</p>

<pre>constructor(scope) {
    this.scope = scope;
}
get element() {
    return this.scope.element;
}
get identifier() {
    return this.scope.identifier;
}
get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
}
set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
}
has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
}
delete(key) {
    if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
    }
    else {
        return false;
    }
}
getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
}</pre>

<p>}</p>

<p>class Guide {</p>

<pre>constructor(logger) {
    this.warnedKeysByObject = new WeakMap;
    this.logger = logger;
}
warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
        warnedKeys = new Set;
        this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
    }
}</pre>

<p>}</p>

<p>function attributeValueContainsToken(attributeName, token) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-string">`[${attributeName}~=&quot;${token}&quot;]`</span>;
</pre>

<p>}</p>

<p>class TargetSet {</p>

<pre>constructor(scope) {
    this.scope = scope;
}
get element() {
    return this.scope.element;
}
get identifier() {
    return this.scope.identifier;
}
get schema() {
    return this.scope.schema;
}
has(targetName) {
    return this.find(targetName) != null;
}
find(...targetNames) {
    return targetNames.reduce((target, targetName) =&gt; target
        || this.findTarget(targetName)
        || this.findLegacyTarget(targetName), undefined);
}
findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) =&gt; [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
    ], []);
}
findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
}
findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
}
getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
}
findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
}
findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map(element =&gt; this.deprecate(element, targetName));
}
getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
}
deprecate(element, targetName) {
    if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}=&quot;${identifier}.${targetName}&quot; with ${revisedAttributeName}=&quot;${targetName}&quot;. ` +
            `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
}
get guide() {
    return this.scope.guide;
}</pre>

<p>}</p>

<p>class Scope {</p>

<pre>constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = (element) =&gt; {
        return element.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
}
findElement(selector) {
    return this.element.matches(selector)
        ? this.element
        : this.queryElements(selector).find(this.containsElement);
}
findAllElements(selector) {
    return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
    ];
}
queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
}
get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
}</pre>

<p>}</p>

<p>class ScopeObserver {</p>

<pre>constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = new WeakMap;
    this.scopeReferenceCounts = new WeakMap;
}
start() {
    this.valueListObserver.start();
}
stop() {
    this.valueListObserver.stop();
}
get controllerAttribute() {
    return this.schema.controllerAttribute;
}
parseValueForToken(token) {
    const { element, content: identifier } = token;
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
    }
    return scope;
}
elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
    }
}
elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
            this.delegate.scopeDisconnected(value);
        }
    }
}
fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
        scopesByIdentifier = new Map;
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
}</pre>

<p>}</p>

<p>class Router {</p>

<pre>constructor(application) {
    this.application = application;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap;
    this.modulesByIdentifier = new Map;
}
get element() {
    return this.application.element;
}
get schema() {
    return this.application.schema;
}
get logger() {
    return this.application.logger;
}
get controllerAttribute() {
    return this.schema.controllerAttribute;
}
get modules() {
    return Array.from(this.modulesByIdentifier.values());
}
get contexts() {
    return this.modules.reduce((contexts, module) =&gt; contexts.concat(module.contexts), []);
}
start() {
    this.scopeObserver.start();
}
stop() {
    this.scopeObserver.stop();
}
loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
}
unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
        this.disconnectModule(module);
    }
}
getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
        return module.contexts.find(context =&gt; context.element == element);
    }
}
handleError(error, message, detail) {
    this.application.handleError(error, message, detail);
}
createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
}
scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
        module.connectContextForScope(scope);
    }
}
scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
        module.disconnectContextForScope(scope);
    }
}
connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach(scope =&gt; module.connectContextForScope(scope));
}
disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach(scope =&gt; module.disconnectContextForScope(scope));
}</pre>

<p>}</p>

<p>const defaultSchema = {</p>

<pre>controllerAttribute: &quot;data-controller&quot;,
actionAttribute: &quot;data-action&quot;,
targetAttribute: &quot;data-target&quot;,
targetAttributeForScope: identifier =&gt; `data-${identifier}-target`</pre>

<p>};</p>

<p>class Application {</p>

<pre>constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) =&gt; {
        if (this.debug) {
            this.logFormattedMessage(identifier, functionName, detail);
        }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
}
static start(element, schema) {
    const application = new Application(element, schema);
    application.start();
    return application;
}
async start() {
    await domReady();
    this.logDebugActivity(&quot;application&quot;, &quot;starting&quot;);
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity(&quot;application&quot;, &quot;start&quot;);
}
stop() {
    this.logDebugActivity(&quot;application&quot;, &quot;stopping&quot;);
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity(&quot;application&quot;, &quot;stop&quot;);
}
register(identifier, controllerConstructor) {
    this.load({ identifier, controllerConstructor });
}
load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach(definition =&gt; {
        if (definition.controllerConstructor.shouldLoad) {
            this.router.loadDefinition(definition);
        }
    });
}
unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach(identifier =&gt; this.router.unloadIdentifier(identifier));
}
get controllers() {
    return this.router.contexts.map(context =&gt; context.controller);
}
getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
}
handleError(error, message, detail) {
    var _a;
    this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
    (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, &quot;&quot;, 0, 0, error);
}
logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({ application: this }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log(&quot;details:&quot;, Object.assign({}, detail));
    this.logger.groupEnd();
}</pre>

<p>} function domReady() {</p>

<pre>return new Promise(resolve =&gt; {
    if (document.readyState == &quot;loading&quot;) {
        document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; resolve());
    }
    else {
        resolve();
    }
});</pre>

<p>}</p>

<p>function ClassPropertiesBlessing(constructor) {</p>

<pre>const classes = readInheritableStaticArrayValues(constructor, &quot;classes&quot;);
return classes.reduce((properties, classDefinition) =&gt; {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
}, {});</pre>

<p>} function propertiesForClassDefinition(key) {</p>

<pre>return {
    [`${key}Class`]: {
        get() {
            const { classes } = this;
            if (classes.has(key)) {
                return classes.get(key);
            }
            else {
                const attribute = classes.getAttributeName(key);
                throw new Error(`Missing attribute &quot;${attribute}&quot;`);
            }
        }
    },
    [`${key}Classes`]: {
        get() {
            return this.classes.getAll(key);
        }
    },
    [`has${capitalize(key)}Class`]: {
        get() {
            return this.classes.has(key);
        }
    }
};</pre>

<p>}</p>

<p>function TargetPropertiesBlessing(constructor) {</p>

<pre>const targets = readInheritableStaticArrayValues(constructor, &quot;targets&quot;);
return targets.reduce((properties, targetDefinition) =&gt; {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
}, {});</pre>

<p>} function propertiesForTargetDefinition(name) {</p>

<pre>return {
    [`${name}Target`]: {
        get() {
            const target = this.targets.find(name);
            if (target) {
                return target;
            }
            else {
                throw new Error(`Missing target element &quot;${name}&quot; for &quot;${this.identifier}&quot; controller`);
            }
        }
    },
    [`${name}Targets`]: {
        get() {
            return this.targets.findAll(name);
        }
    },
    [`has${capitalize(name)}Target`]: {
        get() {
            return this.targets.has(name);
        }
    }
};</pre>

<p>}</p>

<p>function ValuePropertiesBlessing(constructor) {</p>

<pre>const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, &quot;values&quot;);
const propertyDescriptorMap = {
    valueDescriptorMap: {
        get() {
            return valueDefinitionPairs.reduce((result, valueDefinitionPair) =&gt; {
                const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
                const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
                return Object.assign(result, { [attributeName]: valueDescriptor });
            }, {});
        }
    }
};
return valueDefinitionPairs.reduce((properties, valueDefinitionPair) =&gt; {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
}, propertyDescriptorMap);</pre>

<p>} function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {</p>

<pre>const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
const { key, name, reader: read, writer: write } = definition;
return {
    [name]: {
        get() {
            const value = this.data.get(key);
            if (value !== null) {
                return read(value);
            }
            else {
                return definition.defaultValue;
            }
        },
        set(value) {
            if (value === undefined) {
                this.data.delete(key);
            }
            else {
                this.data.set(key, write(value));
            }
        }
    },
    [`has${capitalize(name)}`]: {
        get() {
            return this.data.has(key) || definition.hasCustomDefaultValue;
        }
    }
};</pre>

<p>} function parseValueDefinitionPair([token, typeDefinition], controller) {</p>

<pre>return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition,
});</pre>

<p>} function parseValueTypeConstant(constant) {</p>

<pre>switch (constant) {
    case Array: return &quot;array&quot;;
    case Boolean: return &quot;boolean&quot;;
    case Number: return &quot;number&quot;;
    case Object: return &quot;object&quot;;
    case String: return &quot;string&quot;;
}</pre>

<p>} function parseValueTypeDefault(defaultValue) {</p>

<pre>switch (typeof defaultValue) {
    case &quot;boolean&quot;: return &quot;boolean&quot;;
    case &quot;number&quot;: return &quot;number&quot;;
    case &quot;string&quot;: return &quot;string&quot;;
}
if (Array.isArray(defaultValue))
    return &quot;array&quot;;
if (Object.prototype.toString.call(defaultValue) === &quot;[object Object]&quot;)
    return &quot;object&quot;;</pre>

<p>} function parseValueTypeObject(payload) {</p>

<pre>const typeFromObject = parseValueTypeConstant(payload.typeObject.type);
if (!typeFromObject)
    return;
const defaultValueType = parseValueTypeDefault(payload.typeObject.default);
if (typeFromObject !== defaultValueType) {
    const propertyPath = payload.controller ? `${payload.controller}.${payload.token}` : payload.token;
    throw new Error(`The specified default value for the Stimulus Value &quot;${propertyPath}&quot; must match the defined type &quot;${typeFromObject}&quot;. The provided default value of &quot;${payload.typeObject.default}&quot; is of type &quot;${defaultValueType}&quot;.`);
}
return typeFromObject;</pre>

<p>} function parseValueTypeDefinition(payload) {</p>

<pre>const typeFromObject = parseValueTypeObject({
    controller: payload.controller,
    token: payload.token,
    typeObject: payload.typeDefinition
});
const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition);
const typeFromConstant = parseValueTypeConstant(payload.typeDefinition);
const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
if (type)
    return type;
const propertyPath = payload.controller ? `${payload.controller}.${payload.typeDefinition}` : payload.token;
throw new Error(`Unknown value type &quot;${propertyPath}&quot; for &quot;${payload.token}&quot; value`);</pre>

<p>} function defaultValueForDefinition(typeDefinition) {</p>

<pre>const constant = parseValueTypeConstant(typeDefinition);
if (constant)
    return defaultValuesByType[constant];
const defaultValue = typeDefinition.default;
if (defaultValue !== undefined)
    return defaultValue;
return typeDefinition;</pre>

<p>} function valueDescriptorForTokenAndTypeDefinition(payload) {</p>

<pre>const key = `${dasherize(payload.token)}-value`;
const type = parseValueTypeDefinition(payload);
return {
    type,
    key,
    name: camelize(key),
    get defaultValue() { return defaultValueForDefinition(payload.typeDefinition); },
    get hasCustomDefaultValue() { return parseValueTypeDefault(payload.typeDefinition) !== undefined; },
    reader: readers[type],
    writer: writers[type] || writers.default
};</pre>

<p>} const defaultValuesByType = {</p>

<pre>get array() { return []; },
boolean: false,
number: 0,
get object() { return {}; },
string: &quot;&quot;</pre>

<p>}; const readers = {</p>

<pre>array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type &quot;array&quot; but instead got value &quot;${value}&quot; of type &quot;${parseValueTypeDefault(array)}&quot;`);
    }
    return array;
},
boolean(value) {
    return !(value == &quot;0&quot; || String(value).toLowerCase() == &quot;false&quot;);
},
number(value) {
    return Number(value);
},
object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != &quot;object&quot; || Array.isArray(object)) {
        throw new TypeError(`expected value of type &quot;object&quot; but instead got value &quot;${value}&quot; of type &quot;${parseValueTypeDefault(object)}&quot;`);
    }
    return object;
},
string(value) {
    return value;
}</pre>

<p>}; const writers = {</p>

<pre>default: writeString,
array: writeJSON,
object: writeJSON</pre>

<p>}; function writeJSON(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">stringify</span>(<span class="ruby-identifier">value</span>);
</pre>

<p>} function writeString(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-string">`${value}`</span>;
</pre>

<p>}</p>

<p>class Controller {</p>

<pre>constructor(context) {
    this.context = context;
}
static get shouldLoad() {
    return true;
}
get application() {
    return this.context.application;
}
get scope() {
    return this.context.scope;
}
get element() {
    return this.scope.element;
}
get identifier() {
    return this.scope.identifier;
}
get targets() {
    return this.scope.targets;
}
get classes() {
    return this.scope.classes;
}
get data() {
    return this.scope.data;
}
initialize() {
}
connect() {
}
disconnect() {
}
dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, { detail, bubbles, cancelable });
    target.dispatchEvent(event);
    return event;
}</pre>

<p>} Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing]; Controller.targets = []; Controller.values = {};</p>

<p>export { Application, AttributeObserver, Context, Controller, ElementObserver, IndexedMultimap, Multimap, StringMapObserver, TokenListObserver, ValueListObserver, add, defaultSchema, del, fetch, prune };</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

